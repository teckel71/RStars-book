# Almacenando y manipulando datos.

![[¡Datos, datos!]{.smallcaps}](figuras/02%20robots.jpg){width="100%"}

## ![](figuras/book.svg){.hicon} Objetos. Datos.

Como vimos en el capítulo 1, tras ejecutar un sencillo script (o al escribir instrucciones directamente desde la consola), R es interactivo: responde a las entradas que recibe. Las entradas o **expresiones** pueden ser, básicamente:

-   Expresiones aritméticas.

-   Expresiones lógicas.

-   Llamadas a funciones.

-   Asignaciones.

Las expresiones realizan acciones sobre **objetos** de R. Los objetos en R son entes que tienen ciertas características, *metadatos*, llamados atributos. No todos los objetos tienen los mismos atributos y, ni tan siquiera, todos los objetos tienen atributos que los caractericen.

Los objetos más importantes en R son ciertas estructuras o *contenedores* diseñados para almacenar elementos:

-   Vectores.

-   Matrices.

-   Listas.

-   Data frames.

-   Factores.

Los elementos almacenados en los objetos se dividen en *clases*. Entre las diferentes clases, destacan las clases referidas a **datos**, que pueden ser de diferentes *modos*: logical (verdadero/falso), numeric (números) o character (cadena de texto). El modo numeric puede ser, a la vez, de tipo integer (número entero) o double (número real). En el caso de logical y carácter, modo y tipo coinciden.

Vamos a profundizar un poco en algunas de estos contenedores de datos. Vamos a suponer que trabajamos en el proyecto que creamos en el capítulo anterior (proyecto "explora"), y que vamos a editar el script que también creamos en tal capítulo (script "explorando.R", que se encontrará ubicado en la carpeta del proyecto "explora").

### ![](figuras/key.svg){.hicon} Vectores.

Los **vectores**, son conjuntos de elementos **de la misma clase**. Vamos a definir por ejemplo el vector x = (1,3,5,8). Para ello, vamos a escribir en nuestro script:

```{r, eval=TRUE, echo=TRUE, warning=FALSE}
x <- c(1,3,5,8)
```

Ejecutamos la línea (situando el cursor en algún lugar de ella, dentro del script; y pulsando a la vez las teclas `Control + Enter` o pinchando con el ratón en el botón `Run` del editor). Ya tenemos nuestro primer objeto de tipo *vector* en memoria. Por cierto, lo que hemos hecho es una **asignación**, que se escribe con una flecha creada mediante los signos "\<" y "-". Hemos asignado a un vector llamado "x" los elementos 1, 3, 5 y 8.

Para ver el vector simplemente escribimos en la consola (o en el script) el nombre del vector, "x". El resultado será:

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
x
```

Además, si miramos en la ventana superior-derecha de R-Studio, veremos que en el ***Global Environment*** se muestra nuestro vector y que, además, se nos informa de que tiene *modo* *numérico*. El *Global Environment* nos informa de los objetos que R tiene en memoria:

![Nuestro vector en memoria.](figuras/Imagen2_01.png){.d-block .mx-auto width="100%"}

Si queremos obtener un vector de números consecutivos del 2 al 6, basta con ejecutar en la "consola" (o escribir y ejecutar en el script):

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
y <- c(2:6)
```

Al escribir el nombre del vector "y" en la "consola" obtendremos:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
y
```

Si queremos saber la longitud de un vector, usaremos la *función* `length()`. Por ejemplo, `length(y)` nos devolverá el valor 5. Escribamos en el script y ejecutemos:

```{r, eval=TRUE, echo=TRUE, message= FALSE, warning=FALSE}
length(y)
```

Un vector puede incluir, además de números, caracteres o grupos de caracteres alfanuméricos; siempre entrecomillados (lo fundamental es que sean elementos de la misma clase). Por ejemplo, el vector "genero" (¡no pongamos tildes o podemos tener problemas!). Así, si ejecutamos estas dos líneas de código:

```{r, eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
genero<-c("Mujer","Hombre")
genero
```

Se habrá creado el vector "genero":

```{r,eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
genero<-c("Mujer","Hombre")
genero
```

Podemos obtener la clase de los elementos almacenados en nuestro vector con la función `class()`:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
class(genero)
```

Si falta un dato en un vector, habrá que escribir "NA" (not available). Por ejemplo, si falta el tercer dato de este vector "z", este vector se escribirá como:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
Z <- c(1,2,NA,2,8)
```

Para **seleccionar un elemento** concreto de un vector, indicaremos entre corchetes la posición en la que se encuentra. Por ejemplo, refiriéndonos al vector "x", para obtener el valor de su tercer elemento, haremos:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
x[3]
```

Si queremos que se nos muestren los elementos del vector x del 2º al 4º:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
x[2:4]
```

Por último, si queremos sacar en pantalla los elementos 1º y 4º, tendremos que incluir una "c" seguida de un paréntesis que recoja el orden de los elementos que queremos seleccionar:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
x[c(1,4)]
```

### ![](figuras/key.svg){.hicon} Matrices.

Las **matrices**, internamente en R, son vectores; pero con dos atributos adicionales: número de filas y número de columnas. Se definen mediante la función matrix(). Por ejemplo, para definir la matriz "a":

$$
\begin{pmatrix}
    1 & 4 & 7 \\
    2 & 5 & 8 \\
    3 & 6 & 9
\end{pmatrix}
$$ Tendremos que escribir:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
a <- matrix(c(1,2,3,4,5,6,7,8,9),nrow=3)
a
```

El número de filas de la matriz (y por tanto, el número de columnas) se fija con el argumento `nrow =` . También podríamos fijar el número de columnas, con `ncol =` .

Como vemos, por defecto, R va "cortando" el vector por columnas (si lo preferimos, lo puede hacer también por filas, añadiendo a la función `matrix()` el argumento `by row = true`; pero, en nuestro ejemplo, obtendríamos la matriz traspuesta a la que queremos almacenar).

Las dimensiones (número de filas y de columnas) de la matriz pueden obtenerse mediante la función `dim()`:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
dim(a)
```

3 filas y 3 columnas.

Si queremos seleccionar elementos concretos de una matriz, lo haremos utilizando corchetes para indicar filas y columnas. Hemos de tener en cuenta que, trabajando con matrices, siempre tenemos $$rango de filas, rango de columnas$$ Si se deja en blanco el espacio entre el corchete inicial y la coma, esto querrá decir que consideramos todas las filas. Y si no insertamos nada entre la coma y el corchete de cierre, esto significará que consideramos todas las columnas. A continuación tenemos varios ejemplos de código, con el resultado obtenido en la consola:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
a[2,3]
a[1:2,2:3] 
a[,c(1,3)]
a[c(1,3),]
```

Tanto para vectores como para matrices, funcionan las operaciones suma y diferencia sin más complicaciones. En el caso del producto, sin embargo, hay que tener en cuenta que, por ejemplo, a\*a devuelve la multiplicación elemento a elemento, es decir:

```{r, eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
a*a
```

Devuelve la multiplicación elemento a elemento (en este caso, el cuadrado de cada número, al multiplicar la matriz a por sí misma):

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
a*a
```

Para hacer el verdadero producto matricial deberá introducirse:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
a%*%a
```

### ![](figuras/key.svg){.hicon} Data frames.

Un ***data frame*** es un objeto que almacena datos organizados mediante la clase `data.frame`. Esta organización consiste en que, por filas, se disponen los diferentes casos o sujetos; mientras que por columnas se posicionan las variables. Así:

-   Es similar a una matriz en el sentido de que tiene dos dimensiones. Podemos acceder a sus elementos con corchetes, tenemos nombres de filas y columnas, y podemos operar con ellas.

-   Cada columna tiene un nombre, de manera que podemos acceder a una columna concreta con el símbolo **`$`**. Todas las columnas (variables) son vectores con la misma longitud.

-   Cada columna puede ser un vector numérico, factor, de tipo carácter o lógico.

Por ejemplo, vamos a crear el *data frame* **"datos"**, con tres variables: "peso", "altura", y "color de ojos", llamadas "Peso", "Altura" y "Cl.ojos", respectivamente; para 3 individuos o casos. Una opción es crear primero las tres variables como vectores, y luego crear el *data frame* mediante la función `dataframe()`:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
Peso<-c(68,75,88)
Altura<-c(1.6,1.8,1.9)
Cl.ojos<-c("azules","marrones","marrones")
datos<-data.frame(Peso,Altura,Cl.ojos)
```

Si ahora ejecutamos una línea con el nombre de nuestro *data frame*, lo obtendremos como resultado en la consola:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
datos
```

Para obtener los nombres de las variables (es decir, el nombre de cada columna) teclearemos la función:

```{r, eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
names(datos)
```

Obteniéndose:

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
names(datos)
```

Para obtener solo los datos de la columna (variable) color de ojos teclearemos datos\$Cl.ojos:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
datos$Cl.ojos
```

Y para obtener los datos de peso: datos\$Peso:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
datos$Peso
```

Para saber el número de filas y de columnas de una hoja de datos utilizaremos las funciones `nrow()` y `ncol()`:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
nrow(datos)
ncol(datos)
```

Para seleccionar elementos de un data frame, se pueden seguir las mismas reglas que para la selección de elementos de una matriz (con el número de cada fila, que es cada individuo; y el número de cada columna, que es cada variable. Para elegir una variable, no obstante, ya hemos visto que es posible usar su nombre; aunque precedido del nombre del data frame y el signo `$`. Por ejemplo, si ejecutamos:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
datos[,2]
datos$Altura
```

Obtenemos el mismo resultado.

### ![](figuras/key.svg){.hicon} Factores.

En R, un factor es un tipo especial de objeto que se usa para representar datos categóricos. Es decir, datos que no son números continuos sino que pertenecen a un conjunto limitado de categorías (también llamadas niveles). Por ejemplo, anteriormente creamos el vector "Cl.ojos". Es un vector tipo carácter; pero, para R, aún no es factor.

Para convertirlo en un objeto de la clase "factor", podemos ejecutar:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
Cl.ojosF <- factor(Cl.ojos)
```

En el Global Environment vemos que se ha creado el objaeto "Cl.ojosF", de tipo factor. Si representamos ambos objetos:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
Cl.ojos
Cl.ojosF
```

Vemos como "Cl.ojosF" no es un vector de elementos tipo carácter; sino algo más: es una variable cuyos elementos pueden tomar dos valores categóricos (que pueden estar en el vector una vez, o estar repetidos, o no estar), categorías o niveles, que son "azules" y "marrones".

¿Por qué es necesario, a veces, transformar los datos "categóricos" en "factores"?

-   Ahorro de memoria: internamente, en lugar de guardar “marrones” muchas veces, guarda un número que representa la categoría (ej. 1 = marrones, 2 = azules).

-   Orden y niveles: puedes definir si las categorías del factor están en escala ordinal. Por ejemplo, supongamos que tenemos las siguientes categorías de calificaciones: "Suspenso", "Aprobado", "Notable", "Sobresaliente". Si las guardamos como factor en escala ordinal, R puede saber que Suspenso \< Aprobado \< Notable \< Sobresaliente, lo que te permitirá hacer comparaciones, ordenar, etc.

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
notas <- factor(
  c("Aprobado", "Notable", "Sobresaliente", "Suspenso"),
  levels = c("Suspenso", "Aprobado", "Notable", "Sobresaliente"),
  ordered = TRUE
)
notas
```

-   Modelos estadísticos: muchos métodos de R tratan automáticamente a los factores como variables cualitativas y hacen análisis adecuados (tablas de contingencia, regresiones categóricas, etc.).

En síntesis, Un factor en R es como una etiqueta inteligente para categorías, que permite trabajar con datos cualitativos de forma más organizada y útil para análisis.

### ![](figuras/key.svg){.hicon} Listas.

Por último, una lista es un tipo de objeto que puede contener cualquier cosa dentro:

-   números

-   textos

-   vectores

-   matrices

-   *data frames*

-   otras listas

Es decir, es como una caja organizadora con muchos compartimentos, y en cada compartimento puedes guardar un objeto distinto, tengan la naturaleza que tengan. Por ejemplo, vamos a crear la lista "mi_lista":

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
mi_lista <- list(
  nombre = "María",
  edad = 21,
  notas = c(8.5, 9.0, 7.2),
  aprobado = TRUE
)

mi_lista
```

Esta lista está almacenada en el Global Environment. Si queremos visualizar solo el tercer elemento podemos hacerlo invocando a su posición (con corchetes dobles), o bien a su nombre:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
mi_lista$notas
mi_lista[[3]]

```

Las listas son las estructuras de almacenamiento más flexibles de R, y son muy utilizadas para organizar y empaquetar resultados complejos.

## ![](figuras/pie-chart.svg){.hicon} Importando datos.

Lo más frecuente es que no tecleemos los datos, como hemos hecho hasta ahora; sino que los importemos a R desde algún contenedor externo (archivo de texto, hoja de cálculo, base de datos...). Nosotros vamos a importar nuestros datos desde Microsoft® Excel®. Vamos a cerrar el script que hemos estado construyendo en los apartados anteriores (para conservarlo hay que guardarlo antes), aunque vamos a seguir trabajando en el mismo proyecto (que habíamos llamado "explora"). Iremos a la carpeta del proyecto y guardaremos en ella los dos archivos de esta práctica (obtén el enlace a los archivos en la sección final del capítulo):

-   Un archivo de Microsoft® Excel® llamado "interestelar_100.xlsx"

-   Un script con las instrucciones que vamos a mostrar a continuación, y que se llama "explora_rstars.R"

Si abrimos el archivo de Microsoft® Excel® "interestelar_100.xlsx", comprobaremos que se compone de tres hojas. La primera muestra un aviso sobre el uso exclusivo que se debe dar a los datos incorporados; la segunda recoge la descripción de las variables consideradas; y la tercera (hoja "Datos") guarda los datos que debemos **importar** desde R-Studio. Estos datos se corresponden con diferentes variables económico-financieras y de diverso índole de una muestra de empresas que se dedican al transporte de mercancías interestelar.

Vamos a abrir nuestro script "explora_rstars.R" con `File → Open File…` (o haciendo click en el archivo correspondiente en la ventana inferior derecha de RStudio, pestaña "Files"). Este script contiene el programa que vamos a ir ejecutando en la práctica.

La primera línea / instrucción en los scripts suele ser:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
## Importando datos de las empresas R-Stars

# Limpiando el Global Environment
rm(list = ls())
```

La instrucción tiene como objeto **limpiar el *Global Environment*** (memoria) de objetos de anteriores sesiones de trabajo.

Luego, pueden **cargarse los paquetes que harán falta para ejecutar el código**, si bien se puden cargar en cualquier parte del script (aunque siempre antes de ejecutar una línea que requiera de algún elemento incluido en uno de estos paquetes).

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Cargando paquetes
library(readxl)
library(gtExtras)
```

Obviamente, para cargar o activar un paquete, previamente debe de haber sido instalado en la máquina donde estamos trabajando. Anteriormente hemos visto como instalar un paquete del repositorio *CRAN*. De nuevo, si no hemos instalado antes los paquetes `{readxl}` y `{gtExtras}`, tendremos que instalarlos, o nos dará error.

Para instalar, por ejemplo,el paquete `{readxl}`, (que contiene el código necesario para importar datos de un archivo de Microsoft® Excel®), iremos a la ventana inferior-derecha y pulsaremos la pestaña `Packages`, pulsaremos en `Install`, y emergerá una ventana donde dejaremos el "repositorio" que viene por defecto. En el campo "Packages", escribiremos el nombre del "paquete" que contiene la librería que nos hace falta (normalmente coincide con el nombre de la propia librería, en nuestro caso `{readxl}`. Una vez descargado el "paquete", podremos ejecutar el código anterior sin problemas. Si hemos de instalar el paquete `{gtExtras}`, procederemos de idéntico modo.

Para importar los datos localizados en el archivo de Microsoft® Excel® "interestelar_100.xlsx" el código que podemos usar es:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# DATOS

interestelar_100 <- read_excel("interestelar_100.xlsx", sheet = "Datos", na = c("n.d."))
```

La función encargada de importar los datos es `read_excel()`, del paquete `{readxl}`.

Una cuestión importante a tener en cuenta es que, si hay valores perdidos que, en la hoja de cálculo vienen indicados en las celdas mediante algún tipo de anotación, como por ejemplo, "n.d." (no disponible); deberá incluirse el argumento `na =` para informar de las anotaciones en las celdas que deben traducirse como valores faltantes. Si las celdas sin dato aparecieran en la hoja de cálculo siempre en blanco, este argumento no haría falta.

Volviendo a nuestro ejemplo, podemos observar cómo en el *Environment* ya aparece un objeto. Este objeto es una estructura de datos tipo *data frame*, se llama "interestelar_100" y contiene 104 filas (una por empresa) y 29 columnas, una por cada una de las variables almacenadas en el archivo de Microsoft® Excel®. De estas variables, cinco son de tipo cualitativo, formadas por cadenas de caracteres.

Puede explorarse el contenido del *data frame* y los principales estadísticos con la función `summary()`:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
summary (interestelar_100)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}

library (dplyr)
df <- select(interestelar_100, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(interestelar_100), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(interestelar_100[, i:min(i + variables_por_bloque - 1, ncol(interestelar_100))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Veremos cómo aparecen 29 variables con algunos estadísticos básicos.

R ha considerado a la primera columna como una variable de tipo cualitativo (atributo). En realidad no es una variable, sino el nombre de los individuos o casos. Para evitar que R tome los nombres de los casos como una variable, podemos redefinir nuestro *data frame* diciéndole que considere esa primera columna como los *nombres de los individuos o filas*:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
interestelar_100 <- data.frame(interestelar_100, row.names = 1)
```

En la línea anterior hemos asignado al data frame "interestelar_100" los propios datos de "interestelar_100"; pero indicando que la primera columna de datos no es una variable; sino el nombre de los casos. Si hacemos ahora el `summary()`:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
summary (interestelar_100)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
library (dplyr)
df <- select(interestelar_100, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(interestelar_100), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(interestelar_100[, i:min(i + variables_por_bloque - 1, ncol(interestelar_100))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Vemos que ya no aparece "NOMBRE" como variable, y en el *Environment* ya aparece el data frame "interestelar_100" con 100 observaciones (casos), pero con 28 variables (una menos).

Un modo visualmente más elegante de explorar el contenido del data frame es la utilización de la función `gt_plt_summary()` del paquete `{gtExtras}`:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# visualizando el data frame de modo elegante con {gtExtras}
datos_df_graph <- gt_plt_summary(interestelar_100)
```

Este código asigna al nombre "datos_df_graph" (o al que queramos) un gráfico/tabla con las variables que contiene el data frame (en este caso, "datos", añadiendo características y medidas básicas de las diferentes variables (según sea su tipología). Podremos ver este gráfico/tabla evocando a su nombre:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
datos_df_graph
```

Y el resultado será:

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
# visualizando el data frame de modo elegante con {gtExtras}
datos_df_graph <- gt_plt_summary(interestelar_100)
datos_df_graph
```

Antes de seguir con la manipulación de nuestros datos, es preciso decir que existen otros muchos formatos de datos que pueden ser importados. Por ejemplo, con el paquete `{readr}` se pueden importar datos de archivos de texto de tipo tabular (por ejemplo, archivos \*.csv). Con el paquete `{haven}` se pueden capturar los datos almacenados en archivos de SPSS® (.sav), Stata® (.dta), SAS® (.sas7bdat), etc. Finamente, se pueden capturar datos almacenados en páginas web (archivos en formato JSON o XML, o en tablas HTML)) o en bases de datos gestionadas mediante diversos sistemas (SQLite, MySQL, MariaDB, PostgreSQL, Oracle®).

## ![](figuras/pie-chart.svg){.hicon} {dplyr}.

### ![](figuras/key.svg){.hicon} El Tidyverse. Cargando {dplyr}.

El ***Tidyverse*** es un conjunto de paquetes / librerías con una filosofía común, como es el uso de ciertas estructuras gramaticales, que facilitan muchas de las tareas y análisis que podrían hacerse con el lenguaje R estándar. Una buena obra para profundizar en el Tidyverse es @Wickham2017R.

Uno de esos paquetes es `{dplyr}`, que proporciona una gramática más sencilla que la del lenguaje R convencional para **manipular** los objetos de estructuras de datos conocidos como ***data frames***.

Los data frames, como ya sabemos, son estructuras en las que se almacenan datos de modo que, por columnas, se disponen las variables del análisis; y por filas los casos que conforman la muestra / población.

Vamos a suponer que trabajamos dentro del proyecto que hemos creado previamente, de nombre "explora" (ver capítulo 1), y que seguimos con el script "explora_rstars.R", co el que importamos los datos del archivo de Microsoft® Excel® "interestelar_100.xlsx", que contení información sobre 104 empresas de transporte de mercancías a escala interestelar.

Suponemos que hemos ejecutado la primera parte del script (importación de datos con corrección de la columna de nombres de las filas, al *data frame* interestelar_100, que está almacenado en el *Global Environment.*

Vamos a continuar desde este punto.

A continuación, cargaremos el paquete `{dplyr}`. Si nunca antes se ha utilizado este paquete, cuando lo intentemos activar con la función `library()` nos dará un error o nos dirá que previamente hay que importarlo. En ese caso, iremos a la ventana inferior-derecha y pulsaremos la pestaña "Packages", pulsaremos en `Install`, y emergerá una ventana donde dejaremos el "repositorio" que viene por defecto y, en el campo `Packages`, escribiremos el nombre del "paquete" (en nuestro caso `{dplyr}`). Una vez descargado el "paquete", podremos ejecutar el código sin problemas:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
## dplyr
# Cargando dplyr
library (dplyr)

```

Para entender mejor la **sintaxis** que siguen las funciones o instrucciones a las que da acceso `{dplyr}`, hay que tener en cuenta lo siguiente:

-   El primer argumento que tiene una función de `{dplyr}` es el *data frame* con el que se va a trabajar.

-   Los otros argumentos describen qué hay que hacer con el *data frame* especificado en el primer argumento. Es posible referirse a las columnas (variables) del *data frame* con su nombre, **sin utilizar el operador \$**.

-   El valor de retorno es un **nuevo** *data frame*.

En los siguientes subapartados practicaremos con algunas de las principales funciones que aporta `{dplyr}`.

### ![](figuras/key.svg){.hicon} Seleccionando columnas de un data frame.

La función clave de `{dplyr}` para seleccionar una o varias columnas (variables) de un *data frame* es la función `select()`.

Así, vamos a imaginar por ejemplo que queremos eliminar de nuestro *data frame* la variable (de tipo "carácter") FJUR (forma jurídica de la empresa). Podremos ejecutar la asignación:

```{r, eval=FALSE, echo=TRUE, message=FALSE}

# Seleccionando variables
interestelar_100 <-select(interestelar_100, -FJUR)
summary (interestelar_100)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}

#Seleccionando variables
interestelar_100 <-select(interestelar_100, -FJUR)

library (dplyr)
df <- select(interestelar_100, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(interestelar_100), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(interestelar_100[, i:min(i + variables_por_bloque - 1, ncol(interestelar_100))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Podemos verificar que, en el *Environment,* el *data frame* ha pasado a tener una variable menos (27), ya que hemos eliminado la variable FJUR. Es decir, con el guión "-" se pueden eliminar directamente variables de un *data frame*.

Ahora, suponemos que queremos visualizar las variables del *data frame* "interestelar_100": ACTIVO, FPIOS, LIQUIDEZ. Para ello, ejecutaremos el código:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
select(interestelar_100, ACTIVO, FPIOS, LIQUIDEZ)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
df <-select(interestelar_100, ACTIVO, FPIOS, LIQUIDEZ)
df <- dplyr::slice_head(df, n = 10)  # Solo primeras 10 filas

# Número de columnas por bloque
columnas_por_bloque <- 4

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
}
rm(i)
rm(df)
rm(columnas_por_bloque)
```

(**Nota:** solo mostramos aquí los 10 primeros casos del *data frame*).

Como no hemos asignado el resultado de la función a ningún "nombre", R simplemente muestra el resultado en pantalla; pero no guarda ningún objeto en el *Environment*. Si asignamos un `select()` a un "nombre", se creará un *data frame* con ese nombre, y las variables seleccionadas:

```{r, eval=FALSE, echo=TRUE, message=FALSE}

interestelar_100A <-select(interestelar_100, ACTIVO, FPIOS, LIQUIDEZ)
summary (interestelar_100A)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}

interestelar_100A <-select(interestelar_100, ACTIVO, FPIOS, LIQUIDEZ)

library (dplyr)
df <- select(interestelar_100A, everything())
# Número de variables por bloque
variables_por_bloque <- 3

# Dividir las variables en bloques
for (i in seq(1, ncol(interestelar_100A), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(interestelar_100A[, i:min(i + variables_por_bloque - 1, ncol(interestelar_100A))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Podemos comprobar cómo en el *Global Environment* hay otro objeto *data frame* llamado "interestelar_100A", con 4 variables (y los mismos 104 casos).

Otra posibilidad que tenemos es hacer una copia de un *data frame* rápidamente con el argumento `everything()`. Por ejemplo:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
interestelar_100_replica <-select(interestelar_100, everything())
```

Se ha creado el *date frame* "interestelar_100_replica" que es una copia exacta de "interestelar_100".

### ![](figuras/key.svg){.hicon} Seleccionando casos de un *data frame*.

Además de seleccionar variables, con `{dplyr}` también se pueden seleccionar casos que cumplan ciertas condiciones. La función para realizar este cometido es `filter()`. Por ejemplo, si queremos seleccionar las empresas con un resultado (variable RES) mayor o igual a 500 miles de PAVOs y presentar en pantalla el valor de RES y RENECO, la instrucción será:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# Seleccionando casos
select(filter(interestelar_100, RES >= 500), RES, RENECO)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}

#definir df
df<-select(filter(interestelar_100, RES >= 500), RES, RENECO)

# Número de columnas por bloque
columnas_por_bloque <- 2

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
}
rm(df)
rm(columnas_por_bloque)
```

Se pueden incluir varias condiciones en un mismo filtro. Por ejemplo, vamos a construir un nuevo *data frame* llamado "interestelar_100B" con las empresas que posean un resultado mayor o igual a 500 miles de PAVOs y una rentabilidad económica (variable RENECO) inferior al 40%, y que contenga las variables RES, RENECO y ACTIVO:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
interestelar_100B <-select(filter(interestelar_100,
                                  RES >= 500 & RENECO < 40),
                                  RES, RENECO, ACTIVO)
interestelar_100B
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
interestelar_100B <-select(filter(interestelar_100,
                                  RES >= 500 & RENECO < 40),
                                  RES, RENECO, ACTIVO)
df <- select(interestelar_100B, everything())

# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
  }
rm(df)
rm(columnas_por_bloque)
```

En el *Global* *Environment* aparecerá el *data frame* "interestelar_100B" con solo un caso: la empresa que cumple con ambas condiciones, introducidas mediante el operador lógico relacional "**&**", que es el equivalente a la conjunción "y" o, dicho de otro modo, la intersección. Otro operador lógico relacional muy utilizado es la barra vertical "**\|**", que es el equivalente a la conjunción "o", es decir, la unión.

Los filtros más usuales son \>, \<, \>=, \<=, == (igual, ojo, con dos símbolos de igualdad seguidos) y != (no igual).

### ![](figuras/key.svg){.hicon} Ordenando casos de un *data frame*.

Además de seleccionar determinados casos u observaciones (filas) de un *data frame*, con las funciones de `{dplyr}` también se pueden ordenar estos casos a partir de los valores de ciertas variables (columnas). La función a utilizar es `arrange()`. Esta función, por defecto, ordena los casos de modo **ascendente**. Por ejemplo, creremos el data frame "interestelar_100C" con variables RENECO, EFLO y ACTIVO, con los casos ordenados de modo ascendente según el valor de RENECO:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# Ordenando casos
interestelar_100C <- select(interestelar_100, RENECO, EFLO, ACTIVO)
interestelar_100C <- arrange(interestelar_100C, RENECO)
interestelar_100C
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
interestelar_100C <- select(interestelar_100, RENECO, EFLO, ACTIVO)
interestelar_100C <- arrange(interestelar_100C, RENECO)
df<-interestelar_100C
df <- dplyr::slice_head(df, n = 10)  # Solo primeras 10 filas
# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
  }
rm(df)
rm(columnas_por_bloque)
```

(**Nota:** solo mostramos aquí los 10 primeros casos del *data frame*).

En cambio, para ordenar de modo descendente, hay que utilizar el argumento `desc()`:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
interestelar_100D <- arrange(interestelar_100C, desc(RENECO))
interestelar_100D
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
interestelar_100D <- arrange(interestelar_100C, desc(RENECO))
df<-interestelar_100D
df <- dplyr::slice_head(df, n = 10)  # Solo primeras 10 filas
# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
  }
rm(df)
rm(columnas_por_bloque)
```

(**Nota:** solo mostramos aquí los 10 primeros casos del *data frame*).

En el supuesto de que, en relación con una variable, hubiera varios casos con el mismo valor, podría añadirse otro criterio de ordenación con otra variable, que afectaría a tales casos para deshacer el "empate". Por ejemplo,vamos a ordenar las empresas según la variable EFLO (categorización de la antigüedad promedio de la flota, con categorías: ANTIGUA, MADURA, RENOVADA). Al ser una variable categórica, los casos se ordenarán por orden alfabético según la categoría a la que pertenenecen. Para ordenar los casos pertenecientes a una misma categoría de EFLO, utilizaremos, de nuevo RENECO (en orden de valor descendente):

```{r, eval=FALSE, echo=TRUE, message=FALSE}
interestelar_100E <- arrange(interestelar_100C, EFLO, desc(RENECO))
interestelar_100E
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
interestelar_100E <- arrange(interestelar_100C, EFLO, desc(RENECO))
df<- interestelar_100E
df <- dplyr::slice_head(df, n = 10)  # Solo primeras 10 filas
# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
}
rm(df)
rm(columnas_por_bloque)
rm(i)
```

(**Nota:** solo mostramos aquí los 10 primeros casos del *data frame.* Una vez concluidos los casos con categoría de EFLO "ANTIGUA", comenzarían a aparecer los de categoría "MADURA", desde el caso con posición 52, exactamente).

### ![](figuras/key.svg){.hicon} Cambiando el nombre de las variables de un *data frame*.

`{dplyr}` cuenta con una función que cambia fácilmente el nombre de una variable o columna de un *data frame*: la función `rename()`. Por ejemplo, si queremos cambiar el nombre de la variable SOLVENCIA por SOLVE, simplemente ejecutaremos:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Renombrando variables
interestelar_100 <- rename(interestelar_100, SOLVE = SOLVENCIA)
```

Podemos comprobar en el *Global* *Environment*, despegando el *data frame* "interestelar_100", cómo ya no aparece la variable SOLVENCIA; pero sí SOLVE en su lugar (obviamente, con los mismos datos). Es necesario tener en cuenta que en el **lado izquierdo** de la igualdad hay que poner el **nuevo nombre**, y en la derecha el antiguo. Además, en el mismo `rename()` se pueden cambiar los nombres de **varias variables**, separando las igualdades correspondientes con comas.

### ![](figuras/key.svg){.hicon} Añadiendo variables como transformación de otras variables en un *data frame*.

El paquete `{dplyr}` también permite añadir a un *data frame* variables que son el resultado de **someter a otras variables a diversas transformaciones**. La función para realizar este cometido es `mutate()`.

Así, por ejemplo, imaginemos que necesitamos calcular una variable como el cociente entre los resultados obtenidos y el activo. A esta nueva variable la denominaremos RATIO. El código será:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# Añadiendo variables como transformacion de otras variables
interestelar_100 <- mutate (interestelar_100, RATIO = RES / ACTIVO)
summary(interestelar_100)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
# Añadiendo variables como transformacion de otras variables
interestelar_100 <- mutate (interestelar_100, RATIO = RES / ACTIVO)

library (dplyr)
df <- select(interestelar_100, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(interestelar_100), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(interestelar_100[, i:min(i + variables_por_bloque - 1, ncol(interestelar_100))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

En la transformación de variables mediante la función `mutate()`, se pueden utilizar **funciones integradas en otros paquetes** de R. Por ejemplo, si queremos calcular la variable ACTIVOS_ACUM como la variable que recoge los activos acumulados de las empresas, comenzando por la empresa con menor activo, podríamos utilizar la función `cumsum()` del paquete `{base}`, y hacer:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
interestelar_100 <- arrange(interestelar_100, ACTIVO)
interestelar_100 <- mutate (interestelar_100, ACTIVOS_ACUM = cumsum(ACTIVO))
select(interestelar_100, ACTIVO, ACTIVOS_ACUM)
```

Podemos verificar cómo se ha integrado en el *data frame* la variable ACTIVOS_ACUM:

```{r, eval=TRUE, echo=FALSE, message=FALSE}
interestelar_100 <- arrange(interestelar_100, ACTIVO)
interestelar_100 <- mutate (interestelar_100, ACTIVOS_ACUM = cumsum(ACTIVO))
df<- select(interestelar_100, ACTIVO, ACTIVOS_ACUM)
df <- dplyr::slice_head(df, n = 10)  # Solo primeras 10 filas
# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
}
rm(df)
rm(columnas_por_bloque)
rm(i)
```

(**Nota:** solo mostramos aquí los 10 primeros casos del *data frame)*

Un último ejemplo de adición de una variable que es transformación de otras. En este caso, crearemos la variable DIM (dimensión), que es **categórica** (los datos son conjuntos de caracteres). Esta variable tomará valor "ALTA" para las empresas con un valor de la variable ACTIVO mayor o igual que 216 miles de PAVOs, "MEDIA" para las empresas con un ACTIVO menor que 216 miles de PAVOs y mayor o igual que 54 miles de PAVOs, y "REDUCIDA" para las que tengan un valor en la variable ACTIVO menor que 54 miles de PAVOs. Para calcular automáticamente esta nueva variable categórica, utilizaremos la función de `{base}` llamada `cut()`. De este modo, haremos:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
interestelar_100 <- mutate(interestelar_100,
                           DIM = cut(ACTIVO,
                                 breaks = c(-Inf, 54, 216, Inf),
                                 labels = c("REDUCIDA", "MEDIA", "ALTA")))
select(interestelar_100, ACTIVO, DIM)
```

Podemos advertir cómo la función `cut()`, que incluimos dentro de nuestra función de `{dplyr}` `mutate()`, tiene, a su vez, varios argumentos: la variable numérica de referencia (ACTIVO); el argumento `breaks =`, en el que decimos los intervalos en que quedarán divididos los casos (uno, de menos infinito a 54, otro de 54 a 216, y otro de 216 a más infinito), y `labels =`, que es el valor que tomará la variable creada (DIM) según el intervalo en el que se sitúe cada caso de la muestra:

```{r, eval=TRUE, echo=FALSE, message=FALSE}
interestelar_100 <- mutate(interestelar_100,
                           DIM = cut(ACTIVO,
                                 breaks = c(-Inf, 54, 216, Inf),
                                 labels = c("REDUCIDA", "MEDIA", "ALTA")))
df <-select(interestelar_100, ACTIVO, DIM)
df <- dplyr::slice_head(df, n = 10)  # Solo primeras 10 filas
# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
}
rm(df)
rm(columnas_por_bloque)
rm(i)

```

(**Nota:** solo mostramos aquí los 10 primeros casos del *data frame)*

Cabe destacar que podíamos haber escrito el código para crear la variable DIM de un modo más elegante y cómodo, utilizando **el operador** **"*pipe*"** `%>%`. Este operador permite concatenar una serie de instrucciones:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
interestelar_100 <- interestelar_100 %>%
                              mutate(DIM = cut(ACTIVO,
                                breaks = c(-Inf, 54, 216, Inf),
                                labels = c("REDUCIDA", "MEDIA", "ALTA")))
interestelar_100 %>% select(ACTIVO, DIM)
```

Podríamos interpretar la línea de código así: asigna al *data frame* "interestelar_100" sus propios datos, después (`%>%`) crea la variable DIM con la función `cut()` y añádela a "interestelar_100". En el segundo caso, es más sencillo aún: toma "interestelar_100" y saca en pantalla los valores de las variables ACTIVO y DIM.

### ![](figuras/key.svg){.hicon} Extrayendo y sintetizando información de las variables de un *data frame*.

Otra posibilidad que permite `{dplyr}` es extraer y sintetizar mediante *medidas* la información de las variables contenidas en un *data frame*. Para ello, nos ayudaremos de la función `summarise()`. Como ejemplo, calculemos la *rentabilidad financiera* media de las 20 empresas:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
#Extrayendo información de las variables de un data frame
summarise(interestelar_100, RENFIN_media = mean(RENFIN)) 
```

A veces, es de gran utilidad combinar `summarise()` con `group_by()`, que extrae la información dividiendo el conjunto de casos por grupos definidos por una de las variables. Para ilustrarlo, vamos a utilizar la variable recién creada DIM para hacer tres grupos de empresas, tras lo cual calcularemos la media de las rentabilidades para cada grupo:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
interestelar_100 %>%
  group_by(DIM) %>%
  summarise(RENFIN_media = mean(RENFIN))
```

Hemos utilizado el operador *pipe* `%>%` para concatenar diferentes instrucciones de `{dplyr}`: primero agrupar casos, y luego calcular las medias de cada grupo. Es decir, en este caso se podría "traducir" la línea de código como: "Toma el *data frame*"interestelar_100", divide sus casos en grupos según el valor de la variable DIM, y para cada grupo calcula la media de la variable RENFIN". Es de destacar que hay elementos que tienen como valor categórico en DIM "NA" (es decir, no hay dato). Esto se debe a que, cuando se creo DIM, había una empresa sin valor de ACTIVO (exactamente, "Vega Transport").

## ![](figuras/pie-chart.svg){.hicon}![](figuras/key.svg){.hicon} Exportando datos.

Antes de concluir el capítulo, vamos a tratar brevemente el aspecto de la exportación de datos.

R cuenta con un **formato propio de datos**, que se traduce en archivos de extensión "RData", y que puede incluir cualquier objeto de R. Vamos a exportar el *data frame* "interestelar_100" como el archivo de datos de R "interestelar_100.RData". Posteriormente, borraremos el *data frame* del *Environment* y recuperaremos los datos cargando ese archivo "interestelar_100.RData".

Para exportar el *data frame* "interestelar_100" al archivo de formato R, "interestelar_100.RData", utilizaremos la función `save()`:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
## Exportación de datos

# Exportando data frame a formato R (.RData)
save(interestelar_100, file = "interestelar_100.RData")
```

Puede comprobarse cómo se ha generado el archivo correspondiente en la carpeta de proyecto. Para comprobar que la exportación es correcta, vamos a borrar del *Global* *Environment* el *data frame* "interestelar_100" con la función `rm()` (remove). Después, cargaremos el archivo "interestelar_100.RData" con la función `load()`. Como resultado, podremos comprobar que tenemos un nuevo *data frame* "interestelar_100" que es exactamente igual al que teníamos al principio:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# Borrando el data frame interestelar_100
rm(interestelar_100)

# Importando el archivo .RData con los mismos datos
load("interestelar_100.RData")
summary (interestelar_100)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
# Borrando el data frame interestelar_100
rm(interestelar_100)

# Importando el archivo .RData con los mismos datos
load("interestelar_100.RData")

library (dplyr)
df <- select(interestelar_100, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(interestelar_100), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(interestelar_100[, i:min(i + variables_por_bloque - 1, ncol(interestelar_100))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Por supuesto, hay más formatos en los que se pueden exportar datos desde R. Por ejemplo, **a un archivo de Microsoft® Excel®**. Un modo de hacerlo es haciendo uso de la función `write_xlsx()` del paquete {writexl}. Para que en la hoja de cálculo resultante se incluyan los nombres de las filas (empresas eólicas), hemos tenido previamente que crear un vector con el nombre de estas (vector "NOMBRE"), mediante la función `row.names()`, y unir ese vector al *data frame* "interestelar_100", a modo de primera columna, creando un nuevo finalmente un *data frame* llamado "interestelar_100n", para lo que se ha utilizado la función `cbind()`, que permite **pegar columnas de datos** que tengan un mismo número de filas.

Como resultado de todo el código, se ha obtenido el archivo de Microsoft® Excel® "interestelar_100_new.xlsx":

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Exportando el data frame interestelar_100 a Microsoft (R) Excel (R)
library(writexl)
NOMBRE <- row.names(interestelar_100)
interestelar_100n <- cbind(NOMBRE, interestelar_100)
write_xlsx(interestelar_100n, path = "interestelar_100_new.xlsx")

#Fin del script :)
```

## ![](figuras/star.svg){.hicon} Las variables de la base de datos del proyecto R-Stars.

La base de datos completa del proyecto R-Stars contiene datos económicos, financieros y de diversa índole de 300 empresas de trasnporte interestelar de mercancías, recogidos en unas 30 variables.

El sector del transporte interestelar se extiende a lo largo y ancho de 5 galaxias. Son 30 los planetas donde se localizan las sedes de las 300 empresas.

![[Galaxias y principales planetas del transporte de mercancías.]{.smallcaps}](figuras/mapa_galactico_final.jpg){width="100%"}

Las galaxias donde se desarrolla este tipo de actividad son:

-   **Andrómeda (M31), Vía Láctea y Galaxia del Triángulo (M33):** Son galaxias espirales, caracterizadas por un disco con brazos espirales, un bulbo central y un halo estelar. Presentan componentes como discos delgados y gruesos, bulbos y halos, con poblaciones estelares de diferentes edades y metalicidades.

-   **Gran Nube de Magallanes (LMC) y Pequeña Nube de Magallanes (SMC):** Son galaxias irregulares, con estructuras menos definidas, ricas en gas y con intensa formación estelar. Su morfología es más caótica y carecen de un bulbo central prominente.

En cuanto a las variables que componen la base de dato, son las siguientes (**importante:** estos datos se refieren a la base de datos madre, de 300 casos. No se refiere a la muestra de 104 observaciones utilizada para desarrollar los ejemplos de este capítulo):

**ACTCOR.** Activo corriente. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 6.810, 'q1': 17.450, 'median': 24.005, 'mean': 59.787, 'q3': 55.635, 'max': 889.956}.\
Número estimado de outliers: 36.

**ACTIVO.** Valor total de los recursos de la empresa (miles de PAVOs). Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 17.550, 'q1': 50.530, 'median': 156.315, 'mean': 241.407, 'q3': 227.017, 'max': 2966.520}.\
Número estimado de outliers: 45.

**APALANCA.** Nivel de apalancamiento (Pasivo total / Fondos propios). Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 44.380, 'q1': 100.593, 'median': 121.860, 'mean': 132.667, 'q3': 154.550, 'max': 433.550}.\
Número estimado de outliers: 13.

**BMAL.** Beneficio medio por año luz. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 24.135, 'q1': 466.114, 'median': 1491.416, 'mean': 6084.857, 'q3': 4368.461, 'max': 262555.815}.\
Número estimado de outliers: 31.

**CAPEX.** Gastos de capital. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 1.038, 'q1': 6.156, 'median': 11.600, 'mean': 33.748, 'q3': 34.329, 'max': 1087.196}.\
Número estimado de outliers: 29.

**COSTOP.** Costes operativos. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 0.980, 'q1': 15.305, 'median': 31.195, 'mean': 97.803, 'q3': 105.143, 'max': 1422.300}.\
Número estimado de outliers: 28.

**DIST.** Distancia operada globalmente. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 0.151, 'q1': 12.606, 'median': 44.229, 'mean': 133.686, 'q3': 165.292, 'max': 2151.642}.\
Número estimado de outliers: 26.

**EFLO.** Edad media de la flota (categorías). Tipo de datos: carácter/categórico. NAs: 0.\
Distribución/aproximación: {'ANTIGUA': 148, 'MADURA': 90, 'RENOVADA': 62}.

**EFLO_FACTOR.** Factor derivado de la edad media de la flota. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 0.800, 'q1': 0.800, 'median': 1.000, 'mean': 0.943, 'q3': 1.000, 'max': 1.200}.\
Número estimado de outliers: 0.

**EMPLEA.** Número de empleados. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 7.000, 'q1': 22.750, 'median': 30.000, 'mean': 36.287, 'q3': 44.000, 'max': 106.000}.\
Número estimado de outliers: 16.

**FLOTA.** Número de cargueros espaciales. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 3.000, 'q1': 15.000, 'median': 24.000, 'mean': 26.143, 'q3': 38.000, 'max': 50.000}.\
Número estimado de outliers: 0.

**FJUR.** Forma jurídica de la empresa. Tipo de datos: carácter/categórico. NAs: 0.

**FPIOS.** Fondos propios de la empresa. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 8.670, 'q1': 22.530, 'median': 57.430, 'mean': 111.042, 'q3': 108.408, 'max': 1453.450}.\
Número estimado de outliers: 23.

**FROM.** Inspiración temática de la empresa. Tipo de datos: carácter/categórico. NAs: 0.\
Distribución/aproximación: {'Star Wars': 84, '2001: Una Odisea en el Espacio': 84, 'Dune': 52, 'Star Trek': 47, 'Interstellar': 33}.

**GALAXIA.** Galaxia principal en la que opera la empresa. Tipo de datos: carácter/categórico. NAs: 0.

**GALAXY_FACTOR.** Factor de distancia intergaláctica. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 1.000, 'q1': 1.000, 'median': 2.500, 'mean': 2.812, 'q3': 4.500, 'max': 5.000}.\
Número estimado de outliers: 0.

**GMEDRUT.** Distancia media de las rutas (años luz). Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 0.005, 'q1': 0.112, 'median': 0.224, 'mean': 0.319, 'q3': 0.448, 'max': 1.550}.\
Número estimado de outliers: 10.

**IDIG.** Índice de digitalización. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 0.338, 'q1': 8.498, 'median': 15.672, 'mean': 17.234, 'q3': 23.848, 'max': 60.833}.\
Número estimado de outliers: 4.

**IDIVERSE.** Índice de diversificación. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 0.000, 'q1': 11.655, 'median': 21.165, 'mean': 22.210, 'q3': 32.390, 'max': 78.298}.\
Número estimado de outliers: 2.

**IFIDE.** Índice de fidelización. Tipo de datos: numérico (real o entero). NAs: 0. Observaciones corruptas: 0.\
Distribución/aproximación: {'min': 5.261, 'q1': 36.928, 'median': 39.268, 'mean': 39.002, 'q3': 40.432, 'max': 79.154}.\
Número estimado de outliers: 33.

**IMD.** Gasto en I+D. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 0.478, 'q1': 1.409, 'median': 4.700, 'mean': 15.203, 'q3': 18.240, 'max': 202.478}.\
Número estimado de outliers: 40.

**ING.** Ingresos generados por la actividad principal de la empresa. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 19.400, 'q1': 42.005, 'median': 103.470, 'mean': 218.386, 'q3': 240.973, 'max': 2471.540}.\
Número estimado de outliers: 23.

**LIQUIDEZ.** Cociente entre ACTCOR y PASCOR. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 0.225, 'q1': 0.526, 'median': 0.706, 'mean': 0.702, 'q3': 0.836, 'max': 3.118}.\
Número estimado de outliers: 7.

**MARGEN.** Margen operativo como porcentaje sobre los ingresos. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 12.432, 'q1': 48.095, 'median': 57.449, 'mean': 60.160, 'q3': 73.610, 'max': 96.489}.\
Número estimado de outliers: 0.

**NOMBRE.** Nombre de la empresa. Tipo de datos: carácter/categórico. NAs: 0.

**PASCOR.** Pasivo corriente. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 6.660, 'q1': 20.222, 'median': 59.224, 'mean': 97.773, 'q3': 100.558, 'max': 1143.810}.\
Número estimado de outliers: 25.

**RENECO.** Rentabilidad económica. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 24.082, 'q1': 44.110, 'median': 50.323, 'mean': 51.055, 'q3': 57.745, 'max': 93.847}.\
Número estimado de outliers: 4.

**RENFIN.** Rentabilidad financiera. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 51.388, 'q1': 95.620, 'median': 113.048, 'mean': 116.138, 'q3': 131.138, 'max': 262.245}.\
Número estimado de outliers: 6.

**RES.** Resultado del ejercicio (beneficio neto). Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 9.620, 'q1': 25.315, 'median': 59.220, 'mean': 120.583, 'q3': 128.178, 'max': 1561.930}.\
Número estimado de outliers: 28.

**RUTAS.** Número de rutas atendidas. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 36.000, 'q1': 176.000, 'median': 310.000, 'mean': 365.580, 'q3': 436.500, 'max': 3138.000}.\
Número estimado de outliers: 12.

**SEDE.** Planeta principal donde se encuentra la base de operaciones de la empresa. Tipo de datos: carácter/categórico. NAs: 0.

**SOLVENCIA.** Capacidad de la empresa para cubrir sus obligaciones financieras a largo plazo. Tipo de datos: numérico (real o entero). NAs: 0.\
Distribución/aproximación: {'min': 123.070, 'q1': 164.703, 'median': 182.060, 'mean': 185.718, 'q3': 199.415, 'max': 325.320}.\
Número estimado de outliers: 10.

## ![](figuras/arrow-down-circle.svg){.hicon} Materiales para realizar las prácticas del capítulo.

En esta sección se muestran los links de acceso a los diferentes materiales (*scripts*, datos...) necesarios para llevar a cabo los contenidos prácticos del capítulo.

**Datos (en formato Microsoft® Excel®:**

-   interestelar_100.xlsx ([obtener aquí](https://raw.githubusercontent.com/teckel71/RStars-book/main/download/interestelar_100.xlsx))

**Scripts:**

-   explora_rstars.R ([obtener aquí](https://raw.githubusercontent.com/teckel71/RStars-book/main/download/explora_rstars.R))
