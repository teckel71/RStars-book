# Almacenando y manipulando datos.

![[¡Datos, datos!]{.smallcaps}](figuras/02%20robots.jpg){width="100%"}

## ![](figuras/book.svg){.hicon} Objetos. Datos.

Como vimos en el capítulo 1, tras ejecutar un sencillo script (o al escribir instrucciones directamente desde la consola), R es interactivo: responde a las entradas que recibe. Las entradas o **expresiones** pueden ser, básicamente:

-   Expresiones aritméticas.

-   Expresiones lógicas.

-   Llamadas a funciones.

-   Asignaciones.

Las expresiones realizan acciones sobre **objetos** de R. Los objetos en R son entes que tienen ciertas características, *metadatos*, llamados atributos. No todos los objetos tienen los mismos atributos y, ni tan siquiera, todos los objetos tienen atributos que los caractericen.

Los objetos más importantes en R son ciertas estructuras o *contenedores* diseñados para almacenar elementos:

-   Vectores.

-   Matrices.

-   Listas.

-   Data frames.

-   Factores.

Los elementos almacenados en los objetos se dividen en *clases*. Entre las diferentes clases, destacan las clases referidas a **datos**, que pueden ser de diferentes *modos*: logical (verdadero/falso), numeric (números) o character (cadena de texto). El modo numeric puede ser, a la vez, de tipo integer (número entero) o double (número real). En el caso de logical y carácter, modo y tipo coinciden.

Vamos a profundizar un poco en algunas de estos contenedores de datos. Vamos a suponer que trabajamos en el proyecto que creamos en el capítulo anterior (proyecto "explora"), y que vamos a editar el script que también creamos en tal capítulo (script "explorando.R", que se encontrará ubicado en la carpeta del proyecto "explora").

### ![](figuras/key.svg){.hicon} Vectores.

Los **vectores**, son conjuntos de elementos **de la misma clase**. Vamos a definir por ejemplo el vector x = (1,3,5,8). Para ello, vamos a escribir en nuestro script:

```{r, eval=TRUE, echo=TRUE, warning=FALSE}
x <- c(1,3,5,8)
```

Ejecutamos la línea (situando el cursor en algún lugar de ella, dentro del script; y pulsando a la vez las teclas `Control + Enter` o pinchando con el ratón en el botón `Run` del editor). Ya tenemos nuestro primer objeto de tipo *vector* en memoria. Por cierto, lo que hemos hecho es una **asignación**, que se escribe con una flecha creada mediante los signos "\<" y "-". Hemos asignado a un vector llamado "x" los elementos 1, 3, 5 y 8.

Para ver el vector simplemente escribimos en la consola (o en el script) el nombre del vector, "x". El resultado será:

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
x
```

Además, si miramos en la ventana superior-derecha de R-Studio, veremos que en el ***Global Environment*** se muestra nuestro vector y que, además, se nos informa de que tiene *modo* *numérico*. El *Global Environment* nos informa de los objetos que R tiene en memoria:

![Nuestro vector en memoria.](figuras/Imagen2_01.png){.d-block .mx-auto width="100%"}

Si queremos obtener un vector de números consecutivos del 2 al 6, basta con ejecutar en la "consola" (o escribir y ejecutar en el script):

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
y <- c(2:6)
```

Al escribir el nombre del vector "y" en la "consola" obtendremos:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
y
```

Si queremos saber la longitud de un vector, usaremos la *función* `length()`. Por ejemplo, `length(y)` nos devolverá el valor 5. Escribamos en el script y ejecutemos:

```{r, eval=TRUE, echo=TRUE, message= FALSE, warning=FALSE}
length(y)
```

Un vector puede incluir, además de números, caracteres o grupos de caracteres alfanuméricos; siempre entrecomillados (lo fundamental es que sean elementos de la misma clase). Por ejemplo, el vector "genero" (¡no pongamos tildes o podemos tener problemas!). Así, si ejecutamos estas dos líneas de código:

```{r, eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
genero<-c("Mujer","Hombre")
genero
```

Se habrá creado el vector "genero":

```{r,eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
genero<-c("Mujer","Hombre")
genero
```

Podemos obtener la clase de los elementos almacenados en nuestro vector con la función `class()`:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
class(genero)
```

Si falta un dato en un vector, habrá que escribir "NA" (not available). Por ejemplo, si falta el tercer dato de este vector "z", este vector se escribirá como:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
Z <- c(1,2,NA,2,8)
```

Para **seleccionar un elemento** concreto de un vector, indicaremos entre corchetes la posición en la que se encuentra. Por ejemplo, refiriéndonos al vector "x", para obtener el valor de su tercer elemento, haremos:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
x[3]
```

Si queremos que se nos muestre los elementos del vector x del 2º al 4º:

`{, warning=FALSE{r, eval=TRUE, echo=TRUE, message=FALSE} x[2:4]`

Por último, si queremos sacar en pantalla los elementos 1º y 4º, tendremos que incluir una "c" seguida de un paréntesis que recoja el orden de los elementos que queremos seleccionar:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
x[c(1,4)]
```

### ![](figuras/key.svg){.hicon} Matrices.

Las **matrices**, internamente en R, son vectores; pero con dos atributos adicionales: número de filas y número de columnas. Se definen mediante la función matrix(). Por ejemplo, para definir la matriz "a":

$$
\begin{pmatrix}
    1 & 4 & 7 \\
    2 & 5 & 8 \\
    3 & 6 & 9
\end{pmatrix}
$$ Tendremos que escribir:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
a <- matrix(c(1,2,3,4,5,6,7,8,9),nrow=3)
a
```

El número de filas de la matriz (y por tanto, el número de columnas) se fija con el argumento `nrow =` . También podríamos fijar el número de columnas, con `ncol =` .

Como vemos, por defecto, R va "cortando" el vector por columnas (si lo preferimos, lo puede hacer también por filas, añadiendo a la función `matrix()` el argumento `by row = true`; pero, en nuestro ejemplo, obtendríamos la matriz traspuesta a la que queremos almacenar).

Las dimensiones (número de filas y de columnas) de la matriz pueden obtenerse mediante la función `dim()`:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
dim(a)
```

3 filas y 3 columnas.

Si queremos seleccionar elementos concretos de una matriz, lo haremos utilizando corchetes para indicar filas y columnas. Hemos de tener en cuenta que, trabajando con matrices, siempre tenemos $$rango de filas, rango de columnas$$ Si se deja en blanco el espacio entre el corchete inicial y la coma, esto querrá decir que consideramos todas las filas. Y si no insertamos nada entre la coma y el corchete de cierre, esto significará que consideramos todas las columnas. A continuación tenemos varios ejemplos de código, con el resultado obtenido en la consola:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
a[2,3]
a[1:2,2:3] 
a[,c(1,3)]
a[c(1,3),]
```

Tanto para vectores como para matrices, funcionan las operaciones suma y diferencia sin más complicaciones. En el caso del producto, sin embargo, hay que tener en cuenta que, por ejemplo, a\*a devuelve la multiplicación elemento a elemento, es decir:

```{r, eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
a*a
```

Devuelve la multiplicación elemento a elemento (en este caso, el cuadrado de cada número, al multiplicar la matriz a por sí misma):

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
a*a
```

Para hacer el verdadero producto matricial deberá introducirse:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
a%*%a
```

### ![](figuras/key.svg){.hicon} Data frames.

Un ***data frame*** es un objeto que almacena datos organizados mediante la clase `data.frame`. Esta organización consiste en que, por filas, se disponen los diferentes casos o sujetos; mientras que por columnas se posicionan las variables. Así:

-   Es similar a una matriz en el sentido de que tiene dos dimensiones. Podemos acceder a sus elementos con corchetes, tenemos nombres de filas y columnas, y podemos operar con ellas.

-   Cada columna tiene un nombre, de manera que podemos acceder a una columna concreta con el símbolo **`$`**. Todas las columnas (variables) son vectores con la misma longitud.

-   Cada columna puede ser un vector numérico, factor, de tipo carácter o lógico.

Por ejemplo, vamos a crear el *data frame* **"datos"**, con tres variables: "peso", "altura", y "color de ojos", llamadas "Peso", "Altura" y "Cl.ojos", respectivamente; para 3 individuos o casos. Una opción es crear primero las tres variables como vectores, y luego crear el *data frame* mediante la función `dataframe()`:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
Peso<-c(68,75,88)
Altura<-c(1.6,1.8,1.9)
Cl.ojos<-c("azules","marrones","marrones")
datos<-data.frame(Peso,Altura,Cl.ojos)
```

Si ahora ejecutamos una línea con el nombre de nuestro *data frame*, lo obtendremos como resultado en la consola:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
datos
```

Para obtener los nombres de las variables (es decir, el nombre de cada columna) teclearemos la función:

```{r, eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
names(datos)
```

Obteniéndose:

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
names(datos)
```

Para obtener solo los datos de la columna (variable) color de ojos teclearemos datos\$Cl.ojos:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
datos$Cl.ojos
```

Y para obtener los datos de peso: datos\$Peso:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
datos$Peso
```

Para saber el número de filas y de columnas de una hoja de datos utilizaremos las funciones `nrow()` y `ncol()`:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
nrow(datos)
ncol(datos)
```

Para seleccionar elementos de un data frame, se pueden seguir las mismas reglas que para la selección de elementos de una matriz (con el número de cada fila, que es cada individuo; y el número de cada columna, que es cada variable. Para elegir una variable, no obstante, ya hemos visto que es posible usar su nombre; aunque precedido del nombre del data frame y el signo `$`. Por ejemplo, si ejecutamos:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
datos[,2]
datos$Altura
```

Obtenemos el mismo resultado.

## Importando datos.

Lo más frecuente es que no tecleemos los datos, como hemos hecho hasta ahora; sino que los importemos a R desde algún contenedor externo (archivo de texto, hoja de cálculo, base de datos...). Nosotros vamos a importar nuestros datos desde Microsoft® Excel®. Vamos a cerrar el script que hemos estado construyendo en los apartados anteriores (para conservarlo hay que guardarlo antes), aunque vamos a seguir trabajando en el mismo proyecto (que habíamos llamado "explora"). Iremos a la carpeta del proyecto y guardaremos en ella los dos archivos de esta práctica (obtén el enlace a los archivos en la sección final del capítulo):

-   Un archivo de Microsoft® Excel® llamado "interestelar_100.xlsx"

-   Un script con las instrucciones que vamos a mostrar a continuación, y que se llama "explora_rstars.R"

Si abrimos el archivo de Microsoft® Excel® "interestelar_100.xlsx", comprobaremos que se compone de tres hojas. La primera muestra un aviso sobre el uso exclusivo que se debe dar a los datos incorporados; la segunda recoge la descripción de las variables consideradas; y la tercera (hoja "Datos") guarda los datos que debemos **importar** desde R-Studio. Estos datos se corresponden con diferentes variables económico-financieras y de diverso índole de una muestra de empresas que se dedican al transporte de mercancías interestelar.

Vamos a abrir nuestro script "explora_rstars.R" con `File → Open File…` (o haciendo click en earchivo correspondiente en la ventana inferior derecha de RStudio, pestaña "Files"). Este script contiene el programa que vamos a ir ejecutando en la práctica.

La primera línea / instrucción en los scripts suele ser:

```{r, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
## Importando datos de las empresas R-Stars

# Limpiando el Global Environment
rm(list = ls())
```

La instrucción tiene como objeto **limpiar el *Global Environment*** (memoria) de objetos de anteriores sesiones de trabajo.

Luego, pueden **cargarse los paquetes que harán falta para ejecutar el código**, si bien se puden cargar en cualquier parte del script (aunque siempre antes de ejecutar una línea que requiera de algún elemento incluido en uno de estos paquetes).

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Cargando paquetes
library(readxl)
library(gtExtras)
```

Obviamente, para cargar o activar un paquete, previamente debe de haber sido instalado en la máquina donde estamos trabajando. Anteriormente hemos visto como instalar un paquete del repositorio *CRAN*. De nuevo, si no hemos instalado antes los paquetes `{readxl}` y `{gtExtras}`, tendremos que instalarlos, o nos dará error.

Para instalar, por ejemplo,el paquete `{readxl}`, (que contiene el código necesario para importar datos de un archivo de Microsoft® Excel®), iremos a la ventana inferior-derecha y pulsaremos la pestaña `Packages`, pulsaremos en `Install`, y emergerá una ventana donde dejaremos el "repositorio" que viene por defecto. En el campo "Packages", escribiremos el nombre del "paquete" que contiene la librería que nos hace falta (normalmente coincide con el nombre de la propia librería, en nuestro caso `{readxl}`. Una vez descargado el "paquete", podremos ejecutar el código anterior sin problemas. Si hemos de instalar el paquete `{gtExtras}`, procederemos de idéntico modo.

Para importar los datos localizados en el archivo de Excel® "interestelar_100.xlsx" el código que podemos usar es:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# DATOS

interestelar_100 <- read_excel("interestelar_100.xlsx", sheet = "Datos", na = c("n.d."))
```

La función encargada de importar los datos es `read_excel()`, del paquete `{readxl}`.

Una cuestión importante a tener en cuenta es que, si hay valores perdidos que, en la hoja de cálculo vienen indicados en las celdas mediante algún tipo de anotación, como por ejemplo, "n.d." (no disponible); deberá incluirse el argumento `na =` para informar de las anotaciones en las celdas que deben traducirse como valores faltantes. Si las celdas sin dato aparecieran en la hoja de cálculo siempre en blanco, este argumento no haría falta.

Volviendo a nuestro ejemplo, podemos observar cómo en el *Environment* ya aparece un objeto. Este objeto es una estructura de datos tipo *data frame*, se llama "interestelar_100" y contiene 104 filas (una por empresa) y 29 columnas, una por cada una de las variables almacenadas en el archivo de Microsoft® Excel®. De estas variables, cinco son de tipo cualitativo, formadas por cadenas de caracteres.

Puede explorarse el contenido del *data frame* y los principales estadísticos con la función `summary()`:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
summary (interestelar_100)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}

library (dplyr)
df <- select(interestelar_100, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(interestelar_100), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(interestelar_100[, i:min(i + variables_por_bloque - 1, ncol(interestelar_100))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Veremos cómo aparecen 29 variables con algunos estadísticos básicos.

R ha considerado a la primera columna como una variable de tipo cualitativo (atributo). En realidad no es una variable, sino el nombre de los individuos o casos. Para evitar que R tome los nombres de los casos como una variable, podemos redefinir nuestro *data frame* diciéndole que considere esa primera columna como los *nombres de los individuos o filas*:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
interestelar_100 <- data.frame(interestelar_100, row.names = 1)
```

En la línea anterior hemos asignado al data frame "interestelar_100" los propios datos de "interestelar_100"; pero indicando que la primera columna de datos no es una variable; sino el nombre de los casos. Si hacemos ahora el `summary()`:

```{r, eval=TRUE, echo=FALSE, message=FALSE}
library (dplyr)
df <- select(interestelar_100, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(interestelar_100), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(interestelar_100[, i:min(i + variables_por_bloque - 1, ncol(interestelar_100))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Vemos que ya no aparece "NOMBRE" como variable, y en el *Environment* ya aparece el data frame "interestelar_100" con 100 observaciones (casos), pero con 28 variables (una menos).

Un modo visualmente más elegante de explorar el contenido del data frame es la utilización de la función `gt_plt_summary()` del paquete `{gtExtras}`:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# visualizando el data frame de modo elegante con {gtExtras}
datos_df_graph <- gt_plt_summary(interestelar_100)
```

Este código asigna al nombre "datos_df_graph" (o al que queramos) un gráfico/tabla con las variables que contiene el data frame (en este caso, "datos", añadiendo características y medidas básicas de las diferentes variables (según sea su tipología). Podremos ver este gráfico/tabla evocando a su nombre:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
datos_df_graph
```

Y el resultado será:

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
# visualizando el data frame de modo elegante con {gtExtras}
datos_df_graph <- gt_plt_summary(interestelar_100)
datos_df_graph
```

Antes de seguir con la manipulación de nuestros datos, es preciso decir que existen otros muchos formatos de datos que pueden ser importados. Por ejemplo, con el paquete `{readr}` se pueden importar datos de archivos de texto de tipo tabular (por ejemplo, archivos \*.csv). Con el paquete `{haven}` se pueden capturar los datos almacenados en archivos de SPSS® (.sav), Stata® (.dta), SAS® (.sas7bdat), etc. Finamente, se pueden capturar datos almacenados en páginas web (archivos en formato JSON o XML, o en tablas HTML)) o en bases de datos gestionadas mediante diversos sistemas (SQLite, MySQL, MariaDB, PostgreSQL, Oracle®).

## {dplyr}.

### El Tidyverse. Cargando {dplyr}.

El ***Tidyverse*** es un conjunto de paquetes / librerías con una filosofía común, como es el uso de ciertas estructuras gramaticales, que facilitan muchas de las tareas y análisis que podrían hacerse con el lenguaje R estándar. Una buena obra para profundizar en el Tidyverse es @Wickham2017R.

Uno de esos paquetes es `{dplyr}`, que proporciona una gramática más sencilla que la del lenguaje R convencional para **manipular** los objetos de estructuras de datos conocidos como ***data frames***.

Los data frames, como ya sabemos, son estructuras en las que se almacenan datos de modo que, por columnas, se disponen las variables del análisis; y por filas los casos que conforman la muestra / población.

Vamos a suponer que trabajamos dentro del proyecto que hemos creado previamente, de nombre "explora" (ver capítulo 1). Dentro de la carpeta del proyecto guardaremos el script llamado "explora_dplyr.R" y el archivo de Microsoft® Excel® llamado "eolica_20.xlsx". Si abrimos este último archivo, comprobaremos que se compone de tres hojas. La hoja "Top 20" contiene los datos a importar desde R-Studio. Estos datos se corresponden con diferentes variables económico-financieras de 20 empresas productoras de electricidad mediante generación eólica.

Luego cerraremos el archivo de Microsoft® Excel®, "eolica_20.xlsx", y volveremos a R-Studio. Después, abriremos nuestro script "explora_dplyr.R" con `File → Open File…` Este script contiene el programa que vamos a ir ejecutando en la práctica.

La primera línea / instrucción en los scripts suele ser:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
rm(list = ls())
```

La instrucción tiene como objeto limpiar el *Environment* (memoria) de objetos de anteriores sesiones de trabajo.

Para importar los datos que hay en la hoja "Top 20" del archivo de Microsoft® Excel® llamado "eolica_20.xlsx", ejecutaremos el código:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# DATOS

library(readxl)
eolica_20 <- read_excel("eolica_20.xlsx", sheet = "Top 20")
```

Podemos observar como en el *Environment* ya aparece un objeto. Este objeto es una estructura de datos tipo *data frame*, se llama "eolica_20" y contiene 11 columnas. R ha considerado la primera columna como una variable de tipo cualitativo. En realidad, la primera columna no es una variable, sino que está formada por el nombre (identificador) de los diferentes casos u observaciones. Para evitar que R tome los nombres de los casos como una variable más, podemos redefinir nuestro *data frame* diciéndole que tome esa primera columna como los *nombres de los individuos*:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
eolica_20 <- data.frame(eolica_20, row.names = 1)
```

En la línea anterior hemos asignado al *data frame* "eolica_20" los propios datos de "eolica_20"; pero indicando que la primera columna de datos no es una variable; sino el nombre de los casos.

A continuación, cargaremos el paquete `{dplyr}`. Si nunca antes se ha utilizado este paquete, cuando lo intentemos activar con la función `library()` nos dará un error o nos dirá que previamente hay que importarlo. En ese caso, iremos a la ventana inferior-derecha y pulsaremos la pestaña "Packages", pulsaremos en `Install`, y emergerá una ventana donde dejaremos el "repositorio" que viene por defecto y, en el campo `Packages`, escribiremos el nombre del "paquete" (en nuestro caso `{dplyr}`). Una vez descargado el "paquete", podremos ejecutar el código sin problemas:

```{r, eval=TRUE, echo=TRUE, message=FALSE}

#Cargando dplyr

library (dplyr)

```

Para entender mejor la **sintaxis** que siguen las funciones o instrucciones a las que da acceso `{dplyr}`, hay que tener en cuenta lo siguiente:

-   El primer argumento que tiene una función de `{dplyr}` es el *data frame* con el que se va a trabajar.

-   Los otros argumentos describen qué hay que hacer con el *data frame* especificado en el primer argumento. Es posible referirse a las columnas (variables) del *data frame* con su nombre, **sin utilizar el operador \$**.

-   El valor de retorno es un **nuevo** *data frame*.

En los siguientes subapartados practicaremos con algunas de las principales funciones que aporta `{dplyr}`.

### Seleccionando columnas de un data frame.

La función clave de `{dplyr}` para seleccionar una o varias columnas (variables) de un *data frame* es la función `select()`.

Así, vamos a imaginar por ejemplo que queremos eliminar de nuestro *data frame* la variable (de tipo "carácter") MATRIZ. Podremos ejecutar la asignación:

```{r, eval=FALSE, echo=TRUE, message=FALSE}

#Seleccionando variables

eolica_20 <-select(eolica_20, -MATRIZ)
summary (eolica_20)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}

#Seleccionando variables

eolica_20 <-select(eolica_20, -MATRIZ)

library (dplyr)
df <- select(eolica_20, everything())
# Número de variables por bloque
variables_por_bloque <- 3

# Dividir las variables en bloques
for (i in seq(1, ncol(eolica_20), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(eolica_20[, i:min(i + variables_por_bloque - 1, ncol(eolica_20))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Podemos verificar que, en el *Environment,* el *data frame* ha pasado a tener una variable menos (9), ya que hemos eliminado la variable MATRIZ. Es decir, con el guión "-" se pueden eliminar directamente variables de un *data frame*.

Ahora, suponemos que queremos visualizar las variables del *data frame* "eolica_20": ACTIVO, FPIOS, LIQUIDEZ, MARGEN, SOLVENCIA y APALANCA (es decir, todas las variables menos RES, RENECO, RENFIN). Para ello, ejecutaremos el código:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
select(eolica_20, ACTIVO, FPIOS, LIQUIDEZ, MARGEN, SOLVENCIA, APALANCA)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
df <-select(eolica_20, ACTIVO, FPIOS, LIQUIDEZ, MARGEN, SOLVENCIA, APALANCA)

# Número de columnas por bloque
columnas_por_bloque <- 4

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
}
rm(i)
rm(df)
rm(columnas_por_bloque)
```

Como no hemos asignado el resultado de la función a ningún "nombre", R simplemente saca el resultado en pantalla; pero no guarda ningún objeto en el *Environment*. Si asignamos un `select()` a un "nombre", se creará un *data frame* con ese nombre, y las variables seleccionadas:

```{r, eval=FALSE, echo=TRUE, message=FALSE}

eolica_20A <-select(eolica_20, ACTIVO, FPIOS, LIQUIDEZ, MARGEN, SOLVENCIA, APALANCA)
summary (eolica_20A)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}

eolica_20A <-select(eolica_20, ACTIVO, FPIOS, LIQUIDEZ, MARGEN, SOLVENCIA, APALANCA)

library (dplyr)
df <- select(eolica_20A, everything())
# Número de variables por bloque
variables_por_bloque <- 3

# Dividir las variables en bloques
for (i in seq(1, ncol(eolica_20), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(eolica_20[, i:min(i + variables_por_bloque - 1, ncol(eolica_20))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Podemos comprobar en el *Environment* cómo hay otro objeto *data frame* llamado "eolica_20A", con 6 variables (y los mismos 20 casos). Este *data frame* lo podríamos haber creado, también, eliminando del *data frame* original ("eolica_20"), las variables que nos sobran:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
eolica_20A <-select(eolica_20, -RES, -RENECO, -RENFIN)
```

Más aún, si nos fijamos bien, los nombres de todas las variables que hemos excluido empiezan por "RE", a diferencia de las incluidas. Podríamos haber hecho también:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
eolica_20A <-select(eolica_20, -(starts_with("RE")))
```

Y de nuevo obtendríamos el mismo resultado. El argumento `starts_with()` permite seleccionar variables cuyos nombres comienzan por cierta cadena de caracteres. También se puede hacer mismo con los caracteres finales (`ends_with()`) o contenidos en alguna posición del nombre (`contains()`).

Otra posibilidad que tenemos es hacer una copia de un *data frame* rápidamente con el argumento `everything()`. Por ejemplo:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
eolica_20_replica <-select(eolica_20, everything())
```

Se ha creado el *date frame* "eolica_20_replica" que es una copia exacta de "eolica_20".

### Seleccionando casos de un *data frame*.

Además de seleccionar variables, con `{dplyr}` también se pueden seleccionar casos que cumplan ciertas condiciones. La función para realizar este cometido es `filter()`. Por ejemplo, si queremos seleccionar las empresas eólicas con un resultado (variable RES) mayor o igual a 50.000 y presentarlas en pantalla, la instrucción será:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
filter(eolica_20, RES >= 50000)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}

#definir df
df<-filter(eolica_20, RES >= 50000)

# Número de columnas por bloque
columnas_por_bloque <- 5

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
}
rm(df)
rm(columnas_por_bloque)
```

Se pueden incluir varias condiciones en un mismo filtro. Por ejemplo, vamos a construir un nuevo *data frame* llamado "eolica_20B" con las empresas que posean un resultado mayor o igual a 50000 y una rentabilidad económica (variable RENECO) inferior al 6%:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
eolica_20B <-filter(eolica_20, RES >= 50000 & RENECO < 6)
eolica_20B
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
eolica_20B <-filter(eolica_20, RES >= 50000 & RENECO < 6)
df <- select(eolica_20B, everything())

# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
  }
rm(df)
rm(columnas_por_bloque)
```

En el *Environment* aparecerá el *data frame* "eolica_9B" con solo un caso: la empresa que cumple con ambas condiciones, introducidas mediante el operador lógico relacional "**&**", que es el equivalente a la conjunción "y" o, dicho de otro modo, la intersección. Otro operador lógico relacional muy utilizado es la barra vertical "**\|**", que es el equivalente a la conjunción "o", es decir, la unión.

Los filtros más usuales son \>, \<, \>=, \<=, == (igual, ojo, con dos símbolos de igualdad seguidos) y != (no igual).

### Ordenando casos de un *data frame*.

Además de seleccionar determinados casos u observaciones (filas) de un *data frame*, con las funciones de `{dplyr}` también se pueden ordenar estos casos a partir de los valores de ciertas variables (columnas). La función a utilizar es `arrange()`. Esta función, por defecto, ordena los casos de modo **ascendente**. Por ejemplo:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
arrange(eolica_20, RENECO)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
df<-arrange(eolica_20, RENECO)
# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
  }
rm(df)
rm(columnas_por_bloque)
```

En cambio, para ordenar de modo descendente, hay que utilizar el argumento `desc()`:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
arrange(eolica_20, desc(RENECO))

```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
df<-arrange(eolica_20, desc(RENECO))
# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
  }
rm(df)
rm(columnas_por_bloque)
```

En el supuesto de que, por ejemplo, hubiera varias empresas con la misma rentabilidad económica (RENECO), podría añadirse otro criterio de ordenación con otra variable, que afectaría a tales empresas para deshacer el "empate" en rentabilidad económica. Por ejemplo, para ordenar de modo ascendente por rentabilidad y, en caso de que haya rentabilidades iguales, por liquidez (variable LIQUIDEZ), se ejecutaría:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
arrange(eolica_20, RENECO, LIQUIDEZ)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
df<-arrange(eolica_20, RENECO, LIQUIDEZ)
# Número de columnas por bloque
columnas_por_bloque <- 3

# Dividir las columnas en bloques y mostrar los datos en la consola
for (i in seq(1, ncol(df), columnas_por_bloque)) {
  print(df[, i:min(i + columnas_por_bloque - 1, ncol(df))])
  cat("\n")
}
rm(df)
rm(columnas_por_bloque)
rm(i)
```

Obviamente, en este ejemplo concreto el resultado es el mismo que se obtuvo con `arrange(eolica_20, RENECO)`, puesto que no hay rentabilidades iguales entre las 20 empresas de la muestra.

### Cambiando el nombre de las variables de un *data frame*.

`{dplyr}` cuenta con una función que cambia fácilmente el nombre de una variable o columna de un *data frame*: la función `rename()`. Por ejemplo, si queremos cambiar el nombre de la variable SOLVENCIA por SOLVE, simplemente ejecutaremos:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
#Renombrando variables
eolica_20 <- rename(eolica_20, SOLVE = SOLVENCIA)
```

Podemos comprobar en el *Environment*, despegando el objeto "eolica_20", cómo ya no aparece la variable SOLVENCIA; pero sí SOLVE en su lugar (obviamente, con los mismos datos). Es necesario tener en cuenta que en el **lado izquierdo** de la igualdad hay que poner el **nuevo nombre**, y en la derecha el antiguo. Además, en el mismo `rename()` se pueden cambiar los nombres de **varias variables**, separando las igualdades correspondientes con comas.

### **Añadiendo variables como transformación de otras variables en un *data frame*.**

El paquete `{dplyr}` también permite añadir a un *data frame* variables que son el resultado de **someter a otras variables a diversas transformaciones**. La función para realizar este cometido es `mutate()`.

Así, por ejemplo, imaginemos que necesitamos calcular una variable como el cociente entre los resultados obtenidos y el activo. A esta nueva variable la denominaremos RATIO. El código será:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# Añadiendo variables como transformacion de otras variables
eolica_20 <- mutate (eolica_20, RATIO = RES / ACTIVO)
summary(eolica_20)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
# Añadiendo variables como transformacion de otras variables
eolica_20 <- mutate (eolica_20, RATIO = RES / ACTIVO)

library (dplyr)
df <- select(eolica_20, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(eolica_20), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(eolica_20[, i:min(i + variables_por_bloque - 1, ncol(eolica_20))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

En la transformación de variables mediante la función `mutate()`, se pueden utilizar **funciones integradas en otros paquetes** de R. Por ejemplo, si queremos calcular la variable ACTIVOS_ACUM como la variable que recoge los activos acumulados de las empresas, comenzando por la empresa con menor activo, podríamos utilizar la función `cumsum()` del paquete `{base}`, y hacer:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
eolica_20 <- arrange(eolica_20, ACTIVO)
eolica_20 <- mutate (eolica_20, ACTIVOS_ACUM = cumsum(ACTIVO))
select(eolica_20, ACTIVO, ACTIVOS_ACUM)
```

Podemos verificar cómo se ha integrado en el *data frame* la variable ACTIVOS_ACUM.

Un último ejemplo de adición de una variable que es transformación de otras. En este caso, crearemos la variable TAM (tamaño), que es **categórica** (los datos son conjuntos de carcteres). Esta variable toma valor "G" para las empresas con un valor de la variable ACTIVO mayor que 1.000.000, y "P" para las que tengan un valor en la variable ACTIVO menor o igual a 1.000.000. Para calcular automáticamente esta nueva variable categórica, utilizaremos la función de `{base}` `cut()`. De este modo, haremos:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
eolica_20 <- mutate(eolica_20, TAM = cut(ACTIVO,
  breaks = c(-Inf, 1000000, Inf), labels = c("P", "G")))
select(eolica_20, ACTIVO, TAM)
```

Podemos advertir cómo la función `cut()`, que incluimos dentro de nuestra función de `{dplyr}` `mutate()`, tiene, a su vez, varios argumentos: la variable numérica de referencia (ACTIVO); el argumento **"breaks"**, en el que decimos los intervalos en que quedarán divididos los casos (uno, de menos infinito a 1.000.000; y otro de 1.000.000 a más infinito), y **"labels"**, que es el valor que tomará la variable creada (TAM) según el intervalo en el que se sitúe cada caso de la muestra.

Cabe destacar que podíamos haber escrito el código para crear la variable TAM de un modo más elegante y cómodo, utilizando el operador **"*pipe*"** (**%\>%**). Este operador permite concatenar una serie de instrucciones:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
eolica_20 <- eolica_20 %>% mutate(TAM = cut(ACTIVO,
  breaks = c(-Inf, 1000000, Inf), labels = c("P", "G")))
select(eolica_20, ACTIVO, TAM)
```

Podríamos interpretar la línea de código así: "asigna al *data frame*"eolica_20" sus propios datos, después (%\>%) crea la variable TAM con la función cut() y añádela a "eolica_20".

### Extrayendo y sintetizando información de las variables de un *data frame*.

Otra posibilidad que permite `{dplyr}` es extraer y sintetizar la información de las variables contenidas en un *data frame*. Para ello, nos ayudaremos de la función `summarise()`. Como ejemplo, calculemos la *rentabilidad financiera* media de las 20 empresas:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
#Extrayendo información de las variables de un data frame
summarise(eolica_20, RENFIN_media = mean(RENFIN)) 
```

A veces, es de gran utilidad combinar `summarise()` con `group_by()`, que extrae la información por grupos definidos por una de las variables. Para ilustrarlo, vamos a utilizar la variable recién creada TAM, para hacer dos grupos de empresas: las de menor ("P") y las de mayor ("G") volumen de activo; tras lo cual calcularemos la media de las rentabilidades para cada grupo:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
eolica_20 %>%  group_by(TAM) %>% summarise(RENFIN_media = mean(RENFIN))
```

Hemos utilizado el operador *pipe* (**%\>%)** para concatenar diferentes instrucciones de `{dplyr}`: primero agrupar casos, y luego calcular las medias de cada grupo. Es decir, en este caso se podría "traducir" la línea de código como: "Toma el *data frame*"eolica_9", divide los casos en grupos según el valor de la variable TAM, y para cada grupo calcula la media de la variable RENFIN".

## Exportando datos.

Antes de concluir el capítulo, vamos a tratar brevemente el aspecto de la exportación de datos.

R cuenta con un **formato propio de datos**, que se traduce en archivos de extensión "RData", y que puede incluir cualquier objeto de R. Como ejemplo, en el siguiente *script*, llamado "explora_exporta.R" (obtener aquí), vamos a importar los datos del archivo de Microsoft (R) Excel (R) "eolica_20.xlsx", y el *data frame* donde almacenemos los datos vamos a exportarlo como el archivo de datos de R "eolica_20.RData". Posteriormente, borraremos el *data frame* del *Environment* y recuperaremos los datos cargando ese archivo "eolica_20.RData". Por supuesto, seguimos trabajando, como en todo el capítulo, en el proyecto "explora".

Tras abrir el *script* "explora_exporta.R", las primeras líneas de código que veremos serán las que ya hemos estudiado para borrar el contenido del *Environment*, importar los datos de la hoja "Top 20" del archivo "eolica_20.xlsx" (situado en nuestra carpeta de proyecto), y tratar la variable "NOMBRE" para transformarla en el conjunto de nombres de las filas:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# Exportando datos de empresas eolicas (disculpad la falta de tildes)

rm(list = ls())

# DATOS

library(readxl)
eolica_20 <- read_excel("eolica_20.xlsx", sheet = "Top 20")
eolica_20 <- data.frame(eolica_20, row.names = 1)
summary(eolica_20)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
# Exportando datos de empresas eolicas (disculpad la falta de tildes)

rm(list = ls())

# DATOS

library(readxl)
eolica_20 <- read_excel("eolica_20.xlsx", sheet = "Top 20")
eolica_20 <- data.frame(eolica_20, row.names = 1)

library (dplyr)
df <- select(eolica_20, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(eolica_20), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(eolica_20[, i:min(i + variables_por_bloque - 1, ncol(eolica_20))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Posteriormente, se exportará el data frame "eolica_20" al archivo de formato R, "eolica_20.RData", mediante la función `save`:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Exportando data frame a formato R (.RData)

save(eolica_20, file = "eolica_20.RData")
```

Puede comprobarse cómo se ha generado el archivo correspondiente en la carpeta de proyecto. Para comprobar que la exportación es correcta, vamos a borrar del *Environment* el *data frame* "eolica_20". Después, cargaremos el archivo "eolica_20.RData". Como resultado, podremos comprobar que tenemos un nuevo *data frame* "eolica_20" que es exactamente igual al que teníamos al principio:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# Borrando el data frame eolica_20

rm(eolica_20)

# Importando el archivo .RData con los mismos datos

load("eolica_20.RData")
summary (eolica_20)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
# Borrando el data frame eolica_20

rm(eolica_20)

# Importando el archivo .RData con los mismos datos

load("eolica_20.RData")

library (dplyr)
df <- select(eolica_20, everything())
# Número de variables por bloque
variables_por_bloque <- 4

# Dividir las variables en bloques
for (i in seq(1, ncol(eolica_20), variables_por_bloque)) {
  # Comentario: No mostramos el nombre del bloque
  print(summary(eolica_20[, i:min(i + variables_por_bloque - 1, ncol(eolica_20))]))
  cat("\n")
}
rm (i)
rm (variables_por_bloque)
rm (df)
```

Por supuesto, hay más formatos en los que se pueden exportar datos desde R. Por ejemplo, **a un archivo de Microsoft (R) Excel (R)**. Un modo de hacerlo es haciendo uso de la función `write_xlsx()` del paquete {writexl}. Para que en la hoja de cálculo resultante se incluyan los nombres de las filas (empresas eólicas), hemos tenido previamente que crear un vector con el nombre de estas (vector "NOMBRE"), mediante la función `row.names()`, y unir ese vector al *data frame* "eolica_20", a modo de primera columna, creando un nuevo finalmente un *data frame* llamado "eolica_20n", para lo que se ha utilizado la función `cbind()`, que permite **pegar columnas de datos** que tengan un mismo número de filas.

Como resultado de todo el código, se ha obtenido el archivo de Microsoft (R) Excel (R) "eolica_20_new.xlsx":

```{r, eval=TRUE, echo=TRUE, message=FALSE}

# Exportando el data frame eolica_20 a Microsoft Excel

library(writexl)
NOMBRE <- row.names(eolica_20)
eolica_20n <- cbind(NOMBRE, eolica_20)
write_xlsx(eolica_20n, path = "eolica_20_new.xlsx")

#Fin del script

```

## Materiales para realizar las prácticas del capítulo.

En esta sección se muestran los links de acceso a los diferentes materiales (*scripts*, datos...) necesarios para llevar a cabo los contenidos prácticos del capítulo.

**Datos (en formato Microsoft (R) Excel (R)):**

-   interestelar_100.xlsx ([obtener aquí](https://raw.githubusercontent.com/teckel71/RStars-book/main/download/interestelar_100.xlsx))

**Scripts:**

-   explora_rstars.R ([obtener aquí](https://raw.githubusercontent.com/teckel71/RStars-book/main/download/explora_rstars.R))

-   explora_dplyr.R ([obtener aquí](https://drive.google.com/file/d/1Is4XOd6EmFswB6w2eZfC8_pp2mtu7aQK/view?usp=drive_link))

-   explora_exporta.R ([obtener aquí](https://drive.google.com/file/d/1NVkpJ6toD3pWJsE0w628Sf4e_c5dcffR/view?usp=sharing))
