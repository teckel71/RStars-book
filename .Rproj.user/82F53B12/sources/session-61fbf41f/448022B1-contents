# Estadística descriptiva.

![[Pilotos de Shuttlepod Movers.]{.smallcaps}](figuras/04%20pilotos.jpg){width="100%"}

La Estadística Descriptiva es la parte de la Ciencia Estadística que se ocupa de la recopilación de datos, su depuración, y la caracterización, mediante tales datos, de un conjunto de casos o individuos.

Los datos se organizan en variables y/o atributos.

Las **variables** son características de los casos o individuos en estudio que se plasman en valores que están expresados en **escala métrica**. Los **atributos** son características de los casos o individuos en estudio que se concretan en diversas categorías (si el atributo tiene **escala nominal**) o niveles (si el atributo tiene **escala ordinal**). Los atributos se denominan también variables categóricas, cualitativas o factores.

Centrándonos en las variables (características que afectan a un grupo de casos o individuos, y que se concretan en valores que poseen una escala métrica), podemos plantearnos el estudio de una única variable sin tener en cuenta la existencia de otras variables que caracterizan al mismo grupo de casos o individuos. En tal caso estaremos planteando un **análisis estadístico univariante**. Si nuestro análisis se centra en cómo dos variables caracterizan al mismo conjunto de individuos o casos, y la posible relación entre ambas, estaremos planteando un análisis bivariante. Generalizando, si estudiamos cómo un grupo de variables caracterizan de modo conjunto a un mismo grupo de casos o individuos, estaremos planteando un **análisis estadístico multivariante**.

## ![](figuras/book.svg){.hicon} Análisis univariante.

En el análisis estadístico univariante, estudiamos cómo una única característica (nos centraremos en una variable, aunque también puede tratarse de un atributo) afecta a un grupo de casos, individuos o elementos. Por ejemplo, la variable podría ser el salario percibido por un grupo de individuos que podría ser el conjunto de trabajadores en nómina en una empresa. Otro ejemplo podría ser el de la (variable) rentabilidad económica obtenida por un grupo de empresas pertenecientes a un determinado sector económico.

El conjunto de pares formado por cada valor que puede tomar la variable en estudio (o categoría o nivel, en el caso de un atributo) y el número de casos que toman tal valor se denomina **distribución de frecuencias** de la variable.

¿Cómo podemos estudiar el modo en que afecta una variable, de modo global, a un grupo de casos? Mediante el cálculo de una serie de **medidas**. Las medidas son instrumentos matemáticos que extraen y sintetizan la información contenida en una distribución de frecuencias.

Hay diferentes tipos de medidas, principalmente las de **posición**, **dispersión** y **forma**.

Antes de profundizar en las principales medidas, su significado y su obtención; mostraremos el modo de presentar en R, mediante la creación de tablas, los datos referentes a un grupo de individuos y las variables o atributos que los caracterizan, y las distribuciones de frecuencias univariantes.

Se va a utilizar, a modo de ilustración, los datos correspondientes a los salarios percibidos por una de las empresas de transporte de mercancías interestelar del proyecto *R-Stars*.

## ![](figuras/star.svg){.hicon}*Shuttlepod Movers*.

-   **Origen y Contexto:** Shuttlepod Movers nació en el planeta **Arrakis**, en plena **Gran Nube de Magallanes**, un enclave estratégico del comercio galáctico gracias a su proximidad a fuentes de minerales raros y especias. La empresa se fundó como una **Sociedad Anónima Galáctica (SAG)** con el propósito de atender rutas medianas y largas, apoyándose en la tradición logística de la zona y en la creciente demanda de transporte interestelar durante el siglo XXII. Actualmente, la mayor parte de las acciones de la compañía pertenece a varios empresarios del propio Arrakis. La actual CEO es *Tasha Tachybaptus*, que afronta el reto de la renovación de la flota sin debilitar más la liquidez de la empresa.

![[Nuevo carguero TranStar v.6.]{.smallcaps}](figuras/04%20plano%20carguero.jpg){.d-block .mx-auto width="500"}

-   **Características Operativas:**

    -   Activos: 249,39 mil PAVOs
    -   Flota: 47 cargueros espaciales
    -   Edad media de la flota: *Madura*
    -   Rutas operadas: 594
    -   Distancia global anual: 340,93 millones de años luz
    -   Distancia media por ruta: 0,30 años luz

-   **Situación Financiera:**

    -   Ingresos: 241,73 mil PAVOs
    -   Beneficio neto (RES): 180,82 mil PAVOs
    -   Margen operativo: **74,8%**
    -   Rentabilidad económica (RENECO): 72,5%
    -   Rentabilidad financiera (RENFIN): 167,5%
    -   Solvencia: 176,3%
    -   Apalancamiento: 131
    -   Liquidez: 0,56

::: callout-warning
**Atención**: Aunque la empresa presenta márgenes y rentabilidades muy elevados, la **liquidez reducida** supone un riesgo a corto plazo.
:::

-   **Capital Humano:**

    Plantilla de 49 trabajadores, organizados en áreas como almacén, gestión interna, mantenimiento y operaciones de vuelo. El tamaño de la plantilla es coherente con la escala de la compañía y el mantenimiento de 47 naves operativas.

-   **Innovación y Estrategia:**

    -   Inversión en I+D: 18,5 mil PAVOs
    -   Índice de digitalización (IDIG): 28,1
    -   Índice de diversificación (IDIVERSE): 40,7
    -   Índice de fidelización (IFIDE): 43,1

La empresa presenta una **alta diversificación de mercados** y una **fidelización sólida de clientes**, apoyándose en un grado notable de digitalización para su tamaño.

-   **Diagnóstico General:**

    -   **Fortalezas:**
        -   Márgenes de beneficio extraordinariamente altos.
        -   Excelente rentabilidad financiera y económica.
        -   Diversificación y fidelización destacadas.
    -   **Debilidades:**
        -   Liquidez reducida (riesgo en el corto plazo).
        -   Flota madura que requerirá renovación en próximos ciclos.

## ![](figuras/pie-chart.svg){.hicon} Representando datos y distribuciones de frecuencias en tablas con R.

Para aprender a representar los datos referentes a las variables y atributos que caracterizan a un grupo de casos o individuos, y las distribuciones de frecuencias univariantes, vamos a suponer que trabajamos dentro de un proyecto que hemos creado previamente, de nombre “explora”. Dentro de la carpeta del proyecto guardaremos el *script* llamado “describe_rstars.R” y el archivo de *Microsoft® Excel®* llamado “trabajadores.xlsx”. Al final del capítulo se encuentran los enlaces correspondientes a estos archivos.

El archivo de Excel*®* recoge algunos datos correspondientes a la plantilla que compone el personal de la compañía de transporte de mercancías interestelar *Shuttlepod Movers* (hoja "Datos"), tales como el salario percibido (variable **SALARIO**, expresada en cientos de PAVOs), el nivel de estudios (atributo **NESTUDIOS**) y departamento al que se pertenece (atributo **DEP**).

Las primeras líneas del script se refieren, como ya hemos visto en otras secciones del libro, a la limpieza de la memoria o environment, eliminando objetos que se hayan podido crear con anterioridad, carga de los paquetes necesarios, e importación de los datos:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Script para la construcción de tablas de datos 
# y trabajo con distribuciones de frecuencias univariantes.

# Limpiando el Global Environment
rm(list = ls())

# Cargando paquetes
library(readxl)
library(gtExtras)
library (knitr)
library (kableExtra)
library (dplyr)
library(DescTools)
library(moments)
library (ggplot2)

## DATOS

# Importando datos desde Excel
datos <- read_excel("trabajadores.xlsx",
                    sheet = "Datos",
                    na = c("n.d."))
datos <- data.frame(datos, row.names = 1)

# visualizando el data frame de modo elegante con {gtExtras}
datos_df_graph <- gt_plt_summary(datos)
datos_df_graph
```

Los datos se han almacenado en el *data frame* "datos", y hemos presentado las variables contenidas en el mismo con la función `gt_plt_summary()` del paquete `{gtExtras}` Sabemos que, simplemente escribiendo el nombre del *data frame*, aparecerán en la consola los datos almacenados en él. No obstante, esta presentación no es muy elegante para presentar los datos. Vamos a presentarlos de un modo más amigable, mediante la **confección de una "tabla"**.

Un paquete de R muy popular para generar tablas de datos es `{knitr}`. Este paquete contiene la función `kable()`, que permite generar tablas en varios formatos y con diversas características que pueden ser personalizadas (como el título de la tabla). Si queremos personalizar más aún la apariencia de nuestras tablas, podemos usar las facilidades del paquete `{kableExtra}`, que complementa las posibilidades que ofrece la función `kable()` de `{knitr}`.

Para hacer una tabla con nuestros casos y variables, es decir, para escribir nuestro *data frame* "datos" de un modo más elegante, activaremos los paquetes anteriores (si no lo hemos hecho ya), y generaremos nuestra tabla con los datos contenidos en el *data frame* "datos". El código para generar la tabla, y el resultado, es el siguiente:

```{r, eval=TRUE, echo=FALSE, message=FALSE}
tipo_output <- c("html") # pdf, html, docx
knitr::opts_knit$set(rmarkdown.pandoc.to = tipo_output)
```

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# Tabla de datos
datos %>%
  kable(caption = "Trabajadores de Shuttlepod Movers",
        col.names = c("Trabajador", "Salario", "Nivel de estudios",
                      "Departamento")) %>%
  kable_styling(full_width = F,
                bootstrap_options = "striped", "bordered", "condensed",
                position = "center",
                font_size = 11) %>%
  row_spec(0, bold= T, align = "c") %>%
  row_spec(1:(nrow(datos)), bold= F, align = "c")
```

Primero llamamos al *data frame* a partir de cuyos datos vamos a generar la tabla, "datos". Con el operador *pipe* `%>%`, ligamos los datos del *data frame* al diseño la tabla realizado con la función `kable()` de `{knitr}`. `kable()` tiene diversos argumentos, entre los que destacan:

-   **`caption =`**: Este argumento informa del título de la tabla.

-   **`col.names =`**: Este argumento, opcional, fija el nombre para las columnas de la tabla, si no queremos que aparezcan los nombres "por defecto", que son los nombres de cada columna en el propio *data frame*.

Luego, con el operador *pipe* `%>%` informamos de que vamos a completar o personalizar el diseño de esta tabla con otras funciones complementarias del paquete `{kableExtra}`. En primer lugar, utilizamos la función `kable_styling()`, que aporta algunas características adicionales a la tabla, según sus argumentos:

-   **`full_width =`** : este argumento ha de tener un valor lógico, y se refiere a si deseamos que la tabla ocupe todo el ancho del documento (TRUE) o solo lo necesario (FALSE).

-   **`bootstrap_options =`** : este argumento es de tipo alfanumérico, y sirve para fijar ciertas características estéticas complementarias. "striped" se refiere a que las filas aparezcan sombreadas de modo alternativo, "bordered" se refiere a que cada fila quede delimitada por unas finas líneas en la parte superior y en la inferior, "condensed" significa que la tabla tendrá un aspecto más compacto.

-   **`position =`** : este argumento se utiliza para situar la tabla centrada, a la izquierda del párrafo, o a la derecha.

-   **`font_size =`** : este argumento numérico se refiere al tamaño de los caracteres, lo cuál es importante a la hora de que una tabla "quepa" en un documento de deteminada anchura.

Por último, hacemos uso dos veces de la función `row_spec()` del paquete `{kableExtra}`. Esta función sirve para personalizar algo más las filas concretas de la tabla que consideremos. El encabezado se identifica como la fila "0". En el ejemplo, se ha utilizado esta función dos veces: una para el encabezado (el primer argumento de la función nos informa de las filas a las que se refiere, en esta ocasión la fila 0), y otra para el resto de filas (desde la fila 1 hasta la que contiene al último caso individuo, la fila con posición `nrow(datos)`). Los otros argumentos definen si se quiere que los caracteres aparezcan en negrita (`bold =` ) y cómo deben estar alineados los elementos, dentro de las columnas ( `align =` ).

El resultado es:

```{r, eval=TRUE, echo=FALSE, message=FALSE}
  if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "html") {
datos %>%
  kable(caption = "Trabajadores de Shuttlepod Movers",
        col.names = c("Trabajador", "Salario", "Nivel de estudios",
                      "Departamento")) %>%
  kable_styling(full_width = F,
                bootstrap_options = "striped", "bordered", "condensed",
                position = "center",
                font_size = 11) %>%
  row_spec(0, bold= T, align = "c") %>%
  row_spec(1:(nrow(datos)), bold= F, align = "c")
} else if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "docx") {
  kable(caption = "Trabajadores de Shuttlepod Movers",
        col.names = c("Trabajador", "Salario", "Nivel de estudios",
                      "Departamento"))
} else if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "pdf") {
  kable(caption = "Trabajadores de Shuttlepod Movers",
        col.names = c("Trabajador", "Salario", "Nivel de estudios",
                      "Departamento")) %>%
       kable_styling(latex_options = c("striped", "hold_position"))
}
```

A veces, puede ocurrir que solo nos interese estudiar una variable (columna del *data frame*). Además, es posible que el conjunto de casos sea muy numeroso, y que, adicionalmente, algunos de los valores de la variable que queremos estudiar estén repetidos para varios casos. Cuando esto ocurre, una opción interesante es, en lugar de representar en una tabla todos nuestros datos, **representar la distribución de frecuencias** de la variable (o atributo) que nos interesa. Es lo que vamos a hacer a continuación, tomando SALARIO como variable a analizar.

Lo primero a tener en cuenta es que, en las distribuciones de frecuencias, **los valores de la variable suelen disponerse de menor a mayor**. Para ello, previamente vamos a ordenar las filas del *data frame* "datos" según el valor que toma, en el caso correspondiente, la variable SALARIO y, si existen casos con el mismo valor de SALARIO, los ordenaremos por orden alfabético del nombre del caso (nombre del trabajador, o de la fila del *data frame*). Para realizar este reordenamiento de casos (filas) del *data frame* de un modo sencillo, vamos a utilizar la función `arrange()` del paquete `{deplyr}`:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Distribución de frecuencias del salario de los trabajadores de la empresa.

# Colocar los datos
datos <- datos %>% arrange(SALARIO, row.names(datos))
```

Una vez que los casos están ordenados en el data frame de menor a mayor valor de SALARIO, calcularemos, para cada valor de esta variable, el número de casos que lo poseen, es decir, su frecuencia absoluta. Para ello, vamos a crear un objeto denominado "conteo", que va a ser de clase "table", de la variable SALARIO. Todo ello lo realizamos mediante la función `table()`, que contabiliza el número de veces que aparece cada valor de la variable, como se detalla a continuación:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Contar frecuencias
conteo <- table(datos$SALARIO)
conteo
```

Al mostrar en la consola el "conteo", vemos cómo se compone de dos filas de datos. La primera se corresponde con los valores que toma la variable SALARIO en los distintos casos, y la segunda es el número de casos (**frecuencia absoluta**) que se adopta cada valor. Es decir, el objeto "tabla" es la distribución de frecuencias de la variable SALARIO.

Vamos a convertir este objeto "tabla" en un *data frame*, llamado "conteo_df", con el objeto de poder representar de un modo más elegante la distribución de frecuencias. Para ello, ejecutaremos el código:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Convertir el resultado a un data frame para una mejor visualización
conteo_df <- as.data.frame(conteo)
conteo_df
```

Al mostrar en la consola el *data frame* "conteo_df", observamos que consta de dos columnas o variables. Var1 recoge los valores que toma la variable SALARIO en el grupo de casos, y Freq es el conjunto de frecuencias absolutas de los diferentes valores. Para que se entienda mejor qué es cada columna, las renombraremos:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Renombrar las columnas para mayor claridad
colnames(conteo_df) <- c("Valor", "Frecuencia")
```

A continuación, vamos a calcular el resto de frecuencias que suelen calcularse para una variable. La **frecuencia total**, N, que es la suma de todas las frecuencias absolutas, es decir, el número total de casos, se puede calcular fácilmente como:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Calcular y guardar la frecuencia total
N <- sum(conteo_df$Frecuencia)
```

La serie de frecuencias absolutas acumuladas se calcularán del siguiente modo:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Calcular frecuencias absolutas acumuladas
conteo_df$Frecuencia_acum <- cumsum(conteo_df$Frecuencia)
```

Como sabemos, la última frecuencia absoluta acumulada debe coincidir con la frecuencia total. Por último, calcularemos las frecuencias relativas, que son las frecuencias absolutas divididas por la frecuencia total, y recogen la proporción de casos correspondientes al valor de la variable:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Calcular frecuencias relativas
conteo_df$Frecuencia_R <- conteo_df$Frecuencia / N

# Calcular frecuencias relativas acumuladas
conteo_df$Frecuencia_R_acum <- cumsum(conteo_df$Frecuencia_R)
```

La suma de las frecuencias relativas es siempre 1 (el 100% de los casos). Además, la última frecuencia relativa acumulada siempre es, igualmente, 1.

Ahora pasaremos a construir una tabla que recoja la distribución de frecuencias de la variable SALARIO (con los diversos tipos de frecuencias). Para ello, simplemente hemos de aplicar al *data frame* "conteo_df" las funciones `kable()` del paquete `{knitr}`, y el resto de funciones auxiliares del paquete `{kableExtra}`:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
conteo_df %>%
  kable(caption = "Distribución de frecuencias de salarios. Shuttlepod Movers",
        col.names = c("x(i) = Salario", "Frecuencia absoluta n(i)",
                      "Frecuencia absoluta acum. N(i)", "Frecuencia relativa f(i)",
                      "Frecuencia relativa acum. F(i)"),
        digits  = c(0, 0, 0, 2, 2),
        format.args = list(decimal.mark = ".", scientific = FALSE)) %>%
  kable_styling(full_width = F,
                bootstrap_options = "striped", "bordered", "condensed",
                position = "center",
                font_size = 11) %>%
  row_spec(0, bold= T, align = "c") %>%
  row_spec(1:(nrow(conteo_df)), bold= F, align = "c")
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "html") {
conteo_df %>%
  kable(caption = "Distribución de frecuencias de salarios. Shuttlepod Movers",
        col.names = c("x(i) = Salario", "Frecuencia absoluta n(i)",
                      "Frecuencia absoluta acum. N(i)", "Frecuencia relativa f(i)",
                      "Frecuencia relativa acum. F(i)"),
        digits  = c(0, 0, 0, 2, 2),
        format.args = list(decimal.mark = ".", scientific = FALSE)) %>%
  kable_styling(full_width = F,
                bootstrap_options = "striped", "bordered", "condensed",
                position = "center",
                font_size = 11) %>%
  row_spec(0, bold= T, align = "c") %>%
  row_spec(1:(nrow(conteo_df)), bold= F, align = "c")
} else if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "docx") {
conteo_df %>%
  kable(caption = "Distribución de frecuencias de salarios. Shuttlepod Movers",
        col.names = c("x(i) = Salario", "Frecuencia absoluta n(i)",
                      "Frecuencia absoluta acum. N(i)", "Frecuencia relativa f(i)",
                      "Frecuencia relativa acum. F(i)"),
        digits  = c(0, 0, 0, 2, 2),
        format.args = list(decimal.mark = ".", scientific = FALSE))
}
```

Hemos de advertir que en la función `kable()` se han insertado dos nuevos argumentos:

-   **`digits =`** es un vector que establece, para cada columna, el número de decimales a presentar en la tabla (si es una columna con datos categóricos, se indicará con el valor NA).

-   **`format.args =`** es una "lista" que controla aspectos de formato como si los decimales se indican con un punto o una coma, o si en cifras muy grandes se debe utilizar notación científica.

En cuanto a la interpretación de la distribución, podemos apreciar que la distribución de salarios en *Shuttlepod Movers* refleja una estructura claramente concentrada en los niveles intermedios. La mayor parte de los trabajadores percibe entre 12 y 20 cientos de PAVOs, lo que supone cerca del 70% de la plantilla, mientras que los salarios bajos (8–10) y los más altos (25–30) son minoritarios. Este patrón sugiere una organización con un núcleo amplio de personal con remuneraciones medias, posiblemente operativas o técnicas, y una proporción reducida de empleados en los extremos, que podrían corresponder a personal de apoyo poco cualificado (en la base) y a mandos o especialistas (en la parte alta). Desde el punto de vista económico, la distribución es relativamente equilibrada.

Hay ocasiones en las que la cantidad de valores diferentes que toma la variable analizada para los diferentes casos es muy elevado. Esto puede deberse, por ejemplo, a que el número de casos es muy elevado, o a que la variable es de naturaleza continua, y puede tomar una gran variedad de posibles valores (incluso infinitos). En estos casos, un modo de representar la distribución de frecuencias de la variable en una tabla de dimensión reducida es **agrupando los valores en intervalos**. Esto es lo que vamos a hacer ahora con la variable SALARIO.

La primera tarea a realizar será formar los intervalos. Para ello podemos usar la función `cut()`, que permite decir el número de intervalos (de la misma amplitud) en que queremos dividir el intervalo que va desde el menor valor de la distribución (menor salario) al mayor valor (mayor salario). Vamos a controlar el número de intervalos en que deseamos dividir el rango de valores que puede tomar la variable estudiada mediante una constante ***k***. Si en lugar de decidir nosotros este número, preferimos que sea calculado por un método objetivo, como el de Sturges, ligaremos *k* al método. Por ejemplo:

```{r, eval=TRUE, echo=TRUE, message=FALSE}

# Distribución de frecuencias agrupadas en intervalos
# del salario de los trabajadores de la empresa.

# Crear los intervalos (método de Sturges)
k <- nclass.Sturges(datos$SALARIO)
datos$intervalos <- cut(datos$SALARIO, breaks = k, include.lowest = TRUE)
levels(datos$intervalos)
```

El resultado del código anterior es una nueva columna en el *data frame* "datos", llamada "intervalos", que informa, para cada caso, cuál de los intervalos calculados lo contiene. El argumento lógico `include.lowest =` se especifica para indicar que el intervalo inferior es cerrados por la izquierda. Lo usual es que, salvo este, el resto sean abiertos, es decir, que los casos que toman como valor de la variable un extremo de intervalo se contabilicen dentro del intervalo donde ese valor es el extremo superior.

La columna "intervalos" es de la clase ***factor***. Precisamente, los posibles "niveles" de ese factor son los intervalos que se han creado con `cut()`.

Las siguientes líneas de código son similares a las que vimos en el caso de distribuciones de frecuencias no agrupadas: se creará un objeto "tabla" para contabilizar el número de casos que pertenecen a cada intervalo (frecuencias absolutas), se transformará este objeto en un *data frame* para poder trabajar de un modo más fácil, y se cambiarán el nombre de las dos columnas para que se entienda mejor:

```{r, eval=TRUE, echo=TRUE, message=FALSE}

# Contar las frecuencias de cada intervalo
conteo_intervalos <- table(datos$intervalos)

# Convertir el resultado a un data frame para una mejor visualización
conteo_intervalos_df <- as.data.frame(conteo_intervalos)

# Renombrar las columnas para mayor claridad
colnames(conteo_intervalos_df) <- c("Intervalo", "Frecuencia")
```

Con todo lo anterior, se obtiene un *data frame* denominado "conteo_intervalos_df", que contiene dos columnas: la columna "Intervalo", con los intervalos calculados, y la columna "Frecuencia", con el número de casos que tienen un salario incluido dentro de cada intervalo salarial.

Antes de proceder a diseñar la tabla de presentación de la distribución de frecuencia con `kable()`, vamos a obtener, para incluir en la tabla, otras informaciones que suelen ser presentadas junto a las frecuencias absolutas de cada intervalo.

Una de estas informaciones es lo que denominamos ***marca de clase*** de un intervalo. La marca de clase de un intervalo de valores es simplemente el punto medio de dicho intervalo. La obtención en nuestro ejemplo de las marcas de clase puede resultar algo compleja, ya que hemos de recordar que los intervalos, tal y como están almacenados, son los niveles de una variable de clase f*actor*:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
marca_clase <- sapply(strsplit(as.character(conteo_intervalos_df$Intervalo),
                               ",|\\[|\\(|\\]"),
                      function(x) {mean(as.numeric(x[2:3]))})
```

Explicaremos detenidamente el código anterior:

1.  **`conteo_intervalos_df$Intervalo`**: Aquí se está accediendo a la columna "Intervalo" del *data frame* "conteo_intervalos_df".

2.  **`as.character(conteo_intervalos_df$Intervalo)`**: convierte los valores de la columna "Intervalo" a caracteres (*strings*). Esto es necesario porque la función `strsplit()` trabaja con cadenas de texto.

3.  **`strsplit(as.character(conteo_intervalos_df$Intervalo), ",|\\[|\\(|\\]")`**: `strsplit()` divide cada cadena de texto en partes usando los delimitadores especificados. En este caso, se están utilizando como delimitadores las comas ",", los corchetes "[" y "]", y el paréntesis de apertura "(". Cada separador queda "encerrado" entre una doble barra inclinada "\\\\" (o unas comillas, si es el primer separador que se pone), y una barra vertical "\|" (o unas comillas, si es el último separador que se considera). El resultado es una lista de vectores de caracteres, donde cada vector contiene las partes de la cadena original que estaban separadas por los delimitadores.

4.  **`sapply(..., function(x) { ... })`**: `sapply()` aplica una función a cada elemento de una lista y simplifica el resultado a un vector o matriz. Por otro lado, la función anónima `function(x) { ... }` se aplica a cada vector resultante de `strsplit()`.

5.  **`function(x) { mean(as.numeric(x[2:3])) }`**: Esta es la función anónima que se aplica a cada vector "x". Después, **`x[2:3]`** selecciona el segundo y tercer elemento del vector "x". Estos elementos corresponden con los límites del intervalo. **`as.numeric(x[2:3])`** convierte estos elementos a números. **`mean(as.numeric(x[2:3]))`** calcula la media de estos dos números, que representa el punto medio del intervalo.

6.  **`marca_clase <- ...`**: Finalmente, el resultado de `sapply()` se asigna al vector"marca_clase", que contendrá los puntos medios de los 4 intervalos.

El resto de código integra el vector "marca_clase" en el *data frame* "conteo_intervalo_df" como una variable más, reodena con la función select() del paquete {dplyr} el orden de las columnas del *data frame*, calcula el resto de frecuencias (absoluta acumulada, relativa, relativa acumulada), y diseña la tabla de presentación de la distribución de frecuencias de los salarios de los trabajadores de la empresa; pero agrupada en los intervalos de valores que se fijaron con la constante *k*:

```{r, eval=FALSE, echo=TRUE, message=FALSE}
# Agregar la columna "marca_clase" al data frame
conteo_intervalos_df$marca_clase <- marca_clase

#Cambiar el orden de las columnas en el data frame con dplyr
conteo_intervalos_df <- conteo_intervalos_df %>% select(Intervalo, marca_clase, Frecuencia)

# Calcular y guardar la frecuencia total
N_agre <- sum(conteo_intervalos_df$Frecuencia)

# Calcular frecuencias absolutas acumuladas
conteo_intervalos_df$Frecuencia_acum <- cumsum(conteo_intervalos_df$Frecuencia)

# Calcular frecuencias relativas
conteo_intervalos_df$Frecuencia_R <- conteo_intervalos_df$Frecuencia / N_agre

# Calcular frecuencias relativas acumuladas
conteo_intervalos_df$Frecuencia_R_acum <- cumsum(conteo_intervalos_df$Frecuencia_R)

# Mostrar el resultado
conteo_intervalos_df %>%
  kable(caption = "Distribución de frecuencias agrupadas en intervalos de salarios. Shuttlepod Movers",
        col.names = c("Intervalo salarial",
                      "Marca de clase x(i)",
                      "Frecuencia absoluta n(i)",
                      "Frecuencia absoluta acum. N(i)",
                      "Frecuencia relativa f(i)",
                      "Frecuencia relativa acum. F(i)"),
        digits  = c(NA, 2, 0, 0, 2, 2),
        format.args = list(decimal.mark = ".", scientific = FALSE)) %>%
  kable_styling(full_width = F,
                bootstrap_options = "striped", "bordered", "condensed",
                position = "center",
                font_size = 11) %>%
  row_spec(0, bold= T, align = "c") %>%
  row_spec(1:(nrow(conteo_intervalos_df)), bold= F, align = "c")
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
# Agregar la columna "marca_clase" al data frame
conteo_intervalos_df$marca_clase <- marca_clase

#Cambiar el orden de las columnas en el data frame con dplyr
conteo_intervalos_df <- conteo_intervalos_df %>% select(Intervalo, marca_clase, Frecuencia)

# Calcular y guardar la frecuencia total
N_agre <- sum(conteo_intervalos_df$Frecuencia)

# Calcular frecuencias absolutas acumuladas
conteo_intervalos_df$Frecuencia_acum <- cumsum(conteo_intervalos_df$Frecuencia)

# Calcular frecuencias relativas
conteo_intervalos_df$Frecuencia_R <- conteo_intervalos_df$Frecuencia / N_agre

# Calcular frecuencias relativas acumuladas
conteo_intervalos_df$Frecuencia_R_acum <- cumsum(conteo_intervalos_df$Frecuencia_R)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE}
# Mostrar el resultado
if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "html") {
conteo_intervalos_df %>%
  kable(caption = "Distribución de frecuencias agrupadas en intervalos de salarios. Shuttlepod Movers",
        col.names = c("Intervalo salarial",
                      "Marca de clase x(i)",
                      "Frecuencia absoluta n(i)",
                      "Frecuencia absoluta acum. N(i)",
                      "Frecuencia relativa f(i)",
                      "Frecuencia relativa acum. F(i)"),
        digits  = c(NA, 2, 0, 0, 2, 2),
        format.args = list(decimal.mark = ".", scientific = FALSE)) %>%
  kable_styling(full_width = F,
                bootstrap_options = "striped", "bordered", "condensed",
                position = "center",
                font_size = 11) %>%
  row_spec(0, bold= T, align = "c") %>%
  row_spec(1:(nrow(conteo_intervalos_df)), bold= F, align = "c")
} else if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "docx") {
conteo_intervalos_df %>%
  kable(caption = "Distribución de frecuencias agrupadas en intervalos de salarios. Shuttlepod Movers",
        col.names = c("Intervalo salarial",
                      "Marca de clase x(i)",
                      "Frecuencia absoluta n(i)",
                      "Frecuencia absoluta acum. N(i)",
                      "Frecuencia relativa f(i)",
                      "Frecuencia relativa acum. F(i)"),
        digits  = c(NA, 2, 0, 0, 2, 2),
        format.args = list(decimal.mark = ".", scientific = FALSE))
}
```

La distribución agrupada de salarios en *Shuttlepod Movers,* expresada en cientos de PAVOs, confirma la concentración de la plantilla en niveles intermedios de ingresos. En particular, los intervalos [7.98, 11.1] y (14.3, 17.4] concentran cada uno un 22% de los trabajadores, mientras que los tramos (11.1, 14.3] y (17.4, 20.6] aportan un 16% adicional cada uno. Esto refleja que casi tres cuartas partes de la fuerza laboral percibe salarios entre 8 y 20 cientos de PAVOs, lo que configura una estructura salarial predominantemente media. Los tramos superiores muestran menor densidad: solo un 10% supera los 23.7 cientos de PAVOs, y el salario máximo (30 cientos) corresponde a un único trabajador.

## ![](figuras/book.svg){.hicon}![](figuras/pie-chart.svg){.hicon} Medidas de posición.

Las medidas de posición son instrumentos matemáticos que pretenden, mediante un único valor o muy pocos valores, **caracterizar de modo global** la distribución de frecuencias de una variable determinada.

Las medidas de posición se pueden clasificar en medidas de posición central, y en medidas de posición no central (principalmente, los llamados cuantiles).

Las principales **medidas de posición central** son: la media, la mediana y la moda. Dentro de la media, podemos distinguir la media aritmética, la geométrica y la armónica. De ellas, nos centraremos en la más común: la media aritmética.

La **media aritmética** de la distribución de frecuencias de una variable *X* se calcula como:

$$
\overline{x} = \frac{1}{N} \sum_{i=1}^{h} x_i n_i
$$

Hemos de tener en cuenta en la fórmula anterior que *N* es la frecuencia total, y *h* es el número de valores diferentes que toma la variable.

Si las frecuencias de todos los valores de la variable son 1 (distribución de frecuencias unitarias), lógicamente la media pasará a ser:

$$
\overline{x} = \frac{1}{N} \sum_{i=1}^{N} x_i
$$ En R, la función para obtener la media de una variable es `mean()`. Así, para obtener el salario medio de la variable SALARIO de los trabajadoes de la empresa, ejecutaremos el código:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
## MEDIDAS

# Media aritmética.
media <- mean(datos$SALARIO)
media
```

Como podemos observar, el salario medio de los trabajadores de la empresa, recogido en el valor "media", es de 16.04 cientos de PAVOs, es decir, 1604 PAVOs.

¿Qué significado tiene la media aritmética? La media aritmética es el "centro de gravedad" de la distribución, el punto de equilibrio, en el sentido de que, si todos los trabajadores ganaran el salario medio, no habría diferencias salariales aun cuando la "masa" salarial invertida por la empresa permanecería invariable. Es decir, **la media aritmética supone un reparto igualitario de la masa total de la variable**.

Entre sus ventajas destaca el que, para variables (escala métrica) es siempre calculable y única. Como inconvenientes, que pierde su representatividad ante la existencia de casos atípicos o *outliers*, y que no se puede calcular en el caso de trabajar con atributos, variables cualitativas o factores (escalas nominal u ordinal).

La **mediana** es el valor que se corresponde con el caso o casos que dividen a la distribución en dos grupos con el mismo número de elementos (frecuencias), siempre teniendo en cuenta que, previamente, la distribución ha sido ordenada según los valores de la variable en estudio, de menor a mayor. Si la distribución tiene frecuencia total par, los casos "frontera" entre los dos grupos en que queda dividida la distribución son dos, por lo que, si estos casos asumen valores diferentes en la variable estudiada, podría ocurrir que hubiera dos medianas diferentes. En tal circunstancia, se suele tomar, como convenio, el promedio de de ambos valores para tener una única mediana.

En R, la función para obtener la mediana de una variable es `median()`. De este modo, para obtener el salario mediano de la variable SALARIO de los trabajadoes de la empresa, ejecutaremos el código:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Mediana
mediana <- median(datos$SALARIO)
mediana
```

En el ejemplo de la variable SALARIO, la mediana es 15. Es decir, 15 cientos de PAVOs es el salario percibido por el caso 25, que es el trabajador que divide la distribución de frecuencias en dos grupos de 24 trabajadores: 24 que ganan un salario menor o igual que el caso 25 (menos o igual que 15 cientos de PAVOs), y otros 24 trabajadores que ganan más o lo mismo que el caso en la posición 25 (o sea, igual o más que 15 cientos de PAVOs).

Como ventajas de la mediana, contamos con que no es sensible a la existencia de casos atípicos o outliers, y que se puede calcular en el caso de atributos o factores en escala ordinal. Como desventajas, tenemos que no es necesariamente única, y que no tiene en cuenta la totalidad de los valores de la distribución.

Con **la moda** hacemos referencia al valor (o valores) que posee (o poseen) una mayor frecuencia absoluta.

En R, la moda se calcula mediante la función `Mode()` del paquete `{DescTools}`, que habremos de activar con `library()` (si aún no lo hemos hecho):

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Moda
moda <- Mode(datos$SALARIO)
moda
```

Como podemos apreciar, la moda de la distribución es 15 (un salario de 1500 PAVOs), que aparece en la distribución en 11 ocasiones (la frecuencia absoluta de ese salario es 11).

La moda puede ser calculada en atributos o factores en escala nominal. Como inconveniente principal, tenemos que no necesariamente es un valor único (existen distribuciones multimodales).

Existen otras medidas que son de posición no central, principalmente lo que llamamos **cuantiles**. La naturaleza de los cuantiles es fácil de comprender si los consideramos como una generalización de la mediana. Ya sabemos que, ordenados los valores (y por tanto, los casos que toman dichos valores) de una distribución de frecuencias de una variable de menor a mayor, la mediana es el valor (o valores, porque pueden existir dos medianas, aunque vamos a suponer que solo hay una) de la variable correspondiente al caso que divide a la distribución en dos grupos con el mismo número de frecuencias. Pues bien, si en lugar de dividir a la distribución de frecuencias en dos grupos con el mismo número de elementos, la dividimos en 4 grupos, estaremos hablando de tres valores correspondientes a los casos que delimitan a esos cuatro grupos. Estos valores serán los **cuartiles** de la distribución.

Si queremos dividir la distribución de 9 valores de la variable que toman los casos "frontera" que separan a estos 10 grupos. Esos valores serán los **deciles**. Y si queremos dividir la distribución de frecuencias en 100 grupos con el mismo número de casos o individuos, estaríamos hablando de 99 valores de la variable que toman los casos "frontera" que separan a estos 100 grupos. Esos valores serán los **percentiles**.

En R, la función para calcular los diferentes cuantiles es `quantile()`. Para calcular, por ejemplo, los cuartiles de la variable SALARIO, procederemos así:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Calcular los cuartiles
cuartiles <- quantile(datos$SALARIO, probs = c(0.25, 0.5, 0.75))
cuartiles
```

El argumento `probs =` informa de la proporción de los casos que han de quedar por detrás (con valores menores o iguales) de cada uno de los casos que hacen de "frontera" entre los grupos. En el caso de los cuartiles, estos son 0.25, 0.5 (este cuartil es, a su vez, la mediana de la distribución) y 0.75. Vemos cómo los cuartiles son 12, 15 y 20.

## ![](figuras/book.svg){.hicon}![](figuras/pie-chart.svg){.hicon} Medidas de dispersión o variabilidad.

Las medidas de dispersión cuantifican **lo cerca o lejos que, en general, los valores asumidos por los casos de una distribución de frecuencias se hallan respecto a una medida de posición central**. Si la medida de dispersión toma un valor muy elevado, querrá decir que la medida de posición central no representa bien a la distribución de frecuencias, ya que, en general, los casos toman valores alejados de dicha medida.

La medida de posición central a la que suelen hacer referencia las medidas de dispersión es la media aritmética.

Existen múltiples medidas de dispersión, que principalmente se dividen en **medidas absolutas** (que se expresan en ciertas unidades, como por ejemplo euros, o euros al cuadrado) y **medidas relativas** (que carecen de unidades y siven, por tanto, para comparar la dispersión entre distribuciones de frecuencias expresadas en distintas unidades).

La medida de dispersión absoluta más utilizada es la **varianza**, cuya fórmula es:

$$
S^2 = \frac{1}{N} \sum_{i=1}^{h} (x_i - \overline{x})^2 n_i
$$

Hemos de tener en cuenta en la fórmula anterior que *N* es la frecuencia total, y `h` es el número de valores diferentes que toma la variable.

Si las frecuencias de todos los valores de la variable son 1 (distribución de frecuencias unitarias), lógicamente la varianza pasará a ser:

$$
S^2 = \frac{1}{N} \sum_{i=1}^{N} (x_i - \overline{x})^2
$$

En realidad, la varianza es el promedio de las diferencias que existen entre los valores que toma la variable y la media aritmética de esta, diferencias que son elevadas al cuadrado para evitar la compensación entre diferencias por los signos.

Una limitación de la varianza viene referida a que, debido al exponente del paréntesis, puede tomar valores muy elevados. Para evitar el inconveniente, una medida alternativa es la **desviación típica**, que queda definida como la raíz cuadrada positiva de la varianza:

$$
S = +\sqrt{S^2}
$$

Otra media de dispersión muy utilizada, sobre todo en *Econometría*, es la *varianza insesgada* o **cuasivarianza**, cuya fórmula es:

$$
{\overline{S}}^2 = \frac{1}{N-1} \sum_{i=1}^{h} (x_i - \overline{x})^2 n_i
$$

Como siempre, si las frecuencias de todos los valores de la variable son 1 (distribución de frecuencias unitarias), la cuasivarianza pasará a ser:

$$
{\overline{S}}^2 = \frac{1}{N-1} \sum_{i=1}^{N} (x_i - \overline{x})^2
$$

En cuanto a una medida de dispersión relativa, cabe nombrar al **coeficiente de variación de Pearson**, definido como el cociente entre la desviación típica y la media aritmética (en valor absoluto):

$$
V = \frac{S}{|\overline{x}|}
$$

El coeficiente de variación informa del número de medias aritméticas que "caben" en la desviación típica de una distribución de frecuencias. A mayor coeficiente, mayor dispersión y menor representatividad de la media aritmética con respecto a la distribución. Además, pueden compararse coeficientes de distribuciones expresadas en unidades diferentes (medida relativa).

A continuación, vamos a calcular varianza, desviación típica, cuasivarianza, y coeficiente de variación en R. Para ello, hemos de tener en cuenta que la función `var()` de R, en realidad, calcula la cuasivarianza. Para obtener la varianza, pues, hemos de realizar una corrección (en realidad, para un número de casos muy grande, ambas medidas prácticamente coinciden):

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Varianza
varianza <- var(datos$SALARIO)*(N-1)/N # recordar que la frecuencia total N ya fue calculada
varianza

# Desviación típica
desv <- varianza ^ (1/2)
desv

# Cuasivarianza
cuasivarianza <- var (datos$SALARIO)
cuasivarianza

# Coeficiente de variación
cvariacion <- desv / abs(media)
cvariacion
```

Según los resultados, puede destacarse que el coeficiente de variación indica que en la desviación típica de la variable SALARIO "cabe" el 34,4% de la media.

## ![](figuras/book.svg){.hicon}![](figuras/pie-chart.svg){.hicon} Medidas de forma.

Las medidas de forma cuantifican el grado de deformación horizontal y vertical de la representación gráfica de una distribución de frecuencias. Son de dos tipos: medidas de asimetría y medidas de apuntamiento o curtosis.

Las **medidas de asimetría** miden el grado de deformación horizontal con respecto a un “eje de simetría”, que es aquel que pasa por el valor medio de la distribución. Si suponemos que la distribución es unimodal y campaniforme, tendremos los casos que se muestran en la figura:

![[Tipos de asimetría]{.smallcaps}](figuras/asimetría.png){width="100%"}

El tipo y grado de asimetría se puede obtener mediante el **coeficiente de asimetría de Fisher**. Este coeficiente toma valor negativo si la distribución es *asimétrica negativa* (mayores frecuencias a la derecha de la media), valor positivo si la distribución es *asimétrica positiva* (mayores frecuencias a la izquierda de la media), y se acerca a 0 en caso de que la distribución sea aproximadamente *simétrica*, aunque pueden darse casos de distribuciones no simétricas con coeficiente 0. En R, se puede obtener el coeficiente de asimetría mediante la función `skewness()` del paquete `{moments}`:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Coeficiente de asimetría de Fisher
asimetria <- skewness(datos$SALARIO)
asimetria
```

El valor obtenido para la variable SALARIO de nuestra distribución de frecuencias de los trabajadores de la empresa es positivo, lo que indica asimetría positiva: las mayores frecuencias se localizan a la derecha de la media. Esto se puede comprobar fácilmente construyendo el histograma de la variable SALARIO y trazando una línea vertical que pase por la media salarial. Para ello usamos el paquete `{ggplot2}`:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
ggplot(data = datos,
       map = aes(x = SALARIO)) +
  geom_histogram(bins = k,            # k ya fue definida antes (Sturges)
                 colour = "red",
                 fill = "orange") +
  geom_vline(aes(xintercept = mean(SALARIO)),
             colour = "blue",
             linetype = "dashed",
             linewidth = 1) +
  ggtitle("SALARIO MENSUAL",
          subtitle = "trabajadores de Shuttlepod Movers")+
  xlab("Salario (cientos de PAVOs)") +
  ylab("Frecuencias")
```

Como comprobamos, la distribución es claramente asimétrica positiva.

En cuanto a las **medidas de curtosis**, miden el grado de deformación vertical con respecto a una distribución “tipo”, la distribución normal. Suponemos previamente que la distribución de frecuencias estudiada es campaniforme, unimodal y simétrica (o con ligera asimetría). Pueden darse los casos que se muestran en la figura:

![[Tipos de apuntamiento o curtosis]{.smallcaps}](figuras/curtosis.png){width="100%"}

El tipo y grado de apuntamiento o curtosis se puede obtener mediante el **coeficiente de apuntamiento de Fisher**. Este coeficiente toma valor negativo si la distribución es *platicúrtica* (más aplastada que la distribución normal), valor positivo si la distribución es *leptocúrtica* (más apuntada que la distribución normal), y se acerca a 0 en caso de que la distribución sea aproximadamente igual de apuntada que la distribución normal. En R, se puede obtener el coeficiente de asimetría mediante la función `kurtosis()` del paquete `{moments}`. Hay que tener en cuenta que para que esta versión coincida con lo dicho anteriormente, al valor calculado hay que restarle el valor "3":

```{r, eval=TRUE, echo=TRUE, message=FALSE}
# Coeficiente de apuntamiento o curtosis de Fisher
curtosis <- kurtosis(datos$SALARIO) - 3
curtosis
```

Se aprecia como el coeficiente (corregido) es menor que 0, por lo que la distribución de frecuencias de la variable SALARIO es platicúrtica (más "aplastada" que la distribución de frecuencias normal). También hay que tener en cuenta que debemos prestar atención a la aplicación del coeficiente, ya que vimos con anterioridad que la distribución no es aproximadamente simétrica. Gráficamente, podemos comprobar lo anterior representando el histograma y una curva normal que posea la misma moda (que ya calculamos anteriormente). Para que sean comparables, debemos transformar el eje "y" del gráfico, pasando de "frecuencias" a "densidad", para lo cuál se incluye en el `geom_histogram()` el argumento `aes(y = ..density..)`:

```{r, eval=TRUE, echo=TRUE, message=FALSE}
ggplot(data = datos, map = aes(x = SALARIO)) +
  geom_histogram(bins = k,
                 colour = "red",
                 fill = "orange",
                 aes(y = after_stat(density))) +
  stat_function(fun = dnorm,
                args = list(mean = moda, sd = sd(datos$SALARIO)),
                colour = "darkblue",
                linewidth = 1) +
  ggtitle("SALARIO MENSUAL",
          subtitle = "trabajadores de la empresa Shuttlepod Movers")+
  xlab("Salario (cientos de PAVOs)") +
  ylab("Densidad")
```

El histograma de salarios de *Shuttlepod Movers* muestra con claridad que la mayor densidad de trabajadores se concentra en los tramos intermedios, especialmente entre los 10 y 17 cientos de PAVOs, donde se alcanza el pico de la distribución. A partir de ahí, la frecuencia va disminuyendo progresivamente hacia los intervalos superiores, lo que indica una asimetría positiva: la cola de la distribución se extiende hacia los salarios altos, aunque con muy pocos casos (apenas uno llega a 30 cientos de PAVOs).

Desde un punto de vista económico, la gráfica confirma que la empresa presenta una **estructura salarial relativamente compacta**, dominada por ingresos medios, lo que sugiere un modelo de retribución homogéneo para la mayor parte de la plantilla. Sin embargo, la escasez de salarios muy altos revela **una débil diferenciación jerárquica**, característica de empresas con poca estratificación en su organigrama. Esto puede favorecer la cohesión interna y el control de costes salariales, pero también limita los incentivos para atraer y retener perfiles altamente cualificados en un sector tecnológicamente exigente como el transporte interespacial.

## ![](figuras/arrow-down-circle.svg){.hicon} Materiales para realizar las prácticas del capítulo.

En esta sección se muestran los links de acceso a los diferentes materiales (*scripts*, datos...) necesarios para llevar a cabo los contenidos prácticos del capítulo.

**Datos (en formato Microsoft® Excel®):**

-   interestelar_100.xlsx ([obtener aquí](https://raw.githubusercontent.com/teckel71/RStars-book/main/download/trabajadores.xlsx))

**Scripts:**

-   describe_rstars.R ([obtener aquí](https://raw.githubusercontent.com/teckel71/RStars-book/main/download/describe_rstars.R))
